From a305ab91b86af8a4bdd855da90e96fa53797a8cc Mon Sep 17 00:00:00 2001
From: Grzegorz Bokota <bokota+github@gmail.com>
Date: Mon, 25 Dec 2023 09:37:36 +0100
Subject: [PATCH] Moving IntensityVisualizationMixin from _ImageBase to Image
 (#6548)

The `_ImageBase` class contains many codes required only for `Image`
class. This PR contains extraction of `Image` specific code from
`_ImageBase` to `Image` class.

It also contains update of doc string by removing no longer existing
parameters of constructor.

It also sorts keywords only arguments and parameters to simplify
searching doc strings and maintaining it.

---------

Co-authored-by: Juan Nunez-Iglesias <jni@fastmail.com>
---
 napari/_vispy/layers/image.py                 |  186 +--
 napari/_vispy/layers/labels.py                |   10 +-
 napari/components/viewer_model.py             |    3 +
 napari/layers/base/base.py                    |   23 +-
 napari/layers/image/image.py                  | 1018 ++++++++++-------
 napari/layers/labels/_labels_key_bindings.py  |    8 +-
 .../labels/_tests/test_labels_key_bindings.py |   31 -
 .../labels/_tests/test_labels_multiscale.py   |    3 -
 napari/layers/labels/labels.py                |  161 ++-
 napari/utils/events/evented_model.py          |    1 +
 10 files changed, 852 insertions(+), 592 deletions(-)

diff --git a/napari/_vispy/layers/image.py b/napari/_vispy/layers/image.py
index ee9e24b5..0d6610c7 100644
--- a/napari/_vispy/layers/image.py
+++ b/napari/_vispy/layers/image.py
@@ -13,6 +13,7 @@ from napari._vispy.utils.gl import fix_data_dtype, get_gl_extensions
 from napari._vispy.visuals.image import Image as ImageNode
 from napari._vispy.visuals.volume import Volume as VolumeNode
 from napari.layers.base._base_constants import Blending
+from napari.layers.image.image import Image, _ImageBase
 from napari.utils.translations import trans
 
 
@@ -62,10 +63,10 @@ class ImageLayerNode:
         return res
 
 
-class VispyImageLayer(VispyBaseLayer):
+class VispyScalarFieldBaseLayer(VispyBaseLayer):
     def __init__(
         self,
-        layer,
+        layer: _ImageBase,
         node=None,
         texture_format='auto',
         layer_node_class=ImageLayerNode,
@@ -82,19 +83,7 @@ class VispyImageLayer(VispyBaseLayer):
 
         self.layer.events.rendering.connect(self._on_rendering_change)
         self.layer.events.depiction.connect(self._on_depiction_change)
-        self.layer.events.interpolation2d.connect(
-            self._on_interpolation_change
-        )
-        self.layer.events.interpolation3d.connect(
-            self._on_interpolation_change
-        )
         self.layer.events.colormap.connect(self._on_colormap_change)
-        self.layer.events.contrast_limits.connect(
-            self._on_contrast_limits_change
-        )
-        self.layer.events.gamma.connect(self._on_gamma_change)
-        self.layer.events.iso_threshold.connect(self._on_iso_threshold_change)
-        self.layer.events.attenuation.connect(self._on_attenuation_change)
         self.layer.plane.events.position.connect(
             self._on_plane_position_change
         )
@@ -106,9 +95,10 @@ class VispyImageLayer(VispyBaseLayer):
             self._on_custom_interpolation_kernel_2d_change
         )
 
-        # display_change is special (like data_change) because it requires a self.reset()
-        # this means that we have to call it manually. Also, it must be called before reset
-        # in order to set the appropriate node first
+        # display_change is special (like data_change) because it requires a
+        # self.reset(). This means that we have to call it manually. Also,
+        # it must be called before reset in order to set the appropriate node
+        # first
         self._on_display_change()
         self.reset()
         self._on_data_change()
@@ -188,13 +178,6 @@ class VispyImageLayer(VispyBaseLayer):
         self._on_matrix_change()
         node.update()
 
-    def _on_interpolation_change(self):
-        self.node.interpolation = (
-            self.layer.interpolation2d
-            if self.layer._slice_input.ndisplay == 2
-            else self.layer.interpolation3d
-        )
-
     def _on_custom_interpolation_kernel_2d_change(self):
         if self.layer._slice_input.ndisplay == 2:
             self.node.custom_kernel = self.layer.custom_interpolation_kernel_2d
@@ -202,59 +185,13 @@ class VispyImageLayer(VispyBaseLayer):
     def _on_rendering_change(self):
         if isinstance(self.node, VolumeNode):
             self.node.method = self.layer.rendering
-            self._on_attenuation_change()
-            self._on_iso_threshold_change()
 
     def _on_depiction_change(self):
         if isinstance(self.node, VolumeNode):
             self.node.raycasting_mode = str(self.layer.depiction)
 
-    def _on_colormap_change(self, event=None):
-        self.node.cmap = VispyColormap(*self.layer.colormap)
-
-    def _update_mip_minip_cutoff(self):
-        # discard fragments beyond contrast limits, but only with translucent blending
-        if isinstance(self.node, VolumeNode):
-            if self.layer.blending in {
-                Blending.TRANSLUCENT,
-                Blending.TRANSLUCENT_NO_DEPTH,
-            }:
-                self.node.mip_cutoff = self.node._texture.clim_normalized[0]
-                self.node.minip_cutoff = self.node._texture.clim_normalized[1]
-            else:
-                self.node.mip_cutoff = None
-                self.node.minip_cutoff = None
-
-    def _on_contrast_limits_change(self):
-        self.node.clim = self.layer.contrast_limits
-        # cutoffs must be updated after clims, so we can set them to the new values
-        self._update_mip_minip_cutoff()
-        # iso also may depend on contrast limit values
-        self._on_iso_threshold_change()
-
     def _on_blending_change(self):
         super()._on_blending_change()
-        # cutoffs must be updated after blending, so we can know if
-        # the new blending is a translucent one
-        self._update_mip_minip_cutoff()
-
-    def _on_gamma_change(self):
-        if len(self.node.shared_program.frag._set_items) > 0:
-            self.node.gamma = self.layer.gamma
-
-    def _on_iso_threshold_change(self):
-        if isinstance(self.node, VolumeNode):
-            if self.node._texture.is_normalized:
-                cmin, cmax = self.layer.contrast_limits_range
-                self.node.threshold = (self.layer.iso_threshold - cmin) / (
-                    cmax - cmin
-                )
-            else:
-                self.node.threshold = self.layer.iso_threshold
-
-    def _on_attenuation_change(self):
-        if isinstance(self.node, VolumeNode):
-            self.node.attenuation = self.layer.attenuation
 
     def _on_plane_thickness_change(self):
         if isinstance(self.node, VolumeNode):
@@ -270,10 +207,6 @@ class VispyImageLayer(VispyBaseLayer):
 
     def reset(self, event=None):
         super().reset()
-        self._on_interpolation_change()
-        self._on_colormap_change()
-        self._on_contrast_limits_change()
-        self._on_gamma_change()
         self._on_rendering_change()
         self._on_depiction_change()
         self._on_plane_position_change()
@@ -333,6 +266,111 @@ class VispyImageLayer(VispyBaseLayer):
         return data
 
 
+class VispyImageLayer(VispyScalarFieldBaseLayer):
+    layer: Image
+
+    def __init__(
+        self,
+        layer: Image,
+        node=None,
+        texture_format='auto',
+        layer_node_class=ImageLayerNode,
+    ) -> None:
+        super().__init__(
+            layer,
+            node=node,
+            texture_format=texture_format,
+            layer_node_class=layer_node_class,
+        )
+
+        self.layer.events.interpolation2d.connect(
+            self._on_interpolation_change
+        )
+        self.layer.events.interpolation3d.connect(
+            self._on_interpolation_change
+        )
+        self.layer.events.contrast_limits.connect(
+            self._on_contrast_limits_change
+        )
+        self.layer.events.gamma.connect(self._on_gamma_change)
+        self.layer.events.iso_threshold.connect(self._on_iso_threshold_change)
+        self.layer.events.attenuation.connect(self._on_attenuation_change)
+
+        # display_change is special (like data_change) because it requires a
+        # self.reset(). This means that we have to call it manually. Also,
+        # it must be called before reset in order to set the appropriate node
+        # first
+        self._on_display_change()
+        self.reset()
+        self._on_data_change()
+
+    def _on_interpolation_change(self) -> None:
+        self.node.interpolation = (
+            self.layer.interpolation2d
+            if self.layer._slice_input.ndisplay == 2
+            else self.layer.interpolation3d
+        )
+
+    def _on_rendering_change(self) -> None:
+        super()._on_rendering_change()
+        self._on_attenuation_change()
+        self._on_iso_threshold_change()
+
+    def _on_colormap_change(self, event=None) -> None:
+        self.node.cmap = VispyColormap(*self.layer.colormap)
+
+    def _update_mip_minip_cutoff(self) -> None:
+        # discard fragments beyond contrast limits, but only with translucent blending
+        if isinstance(self.node, VolumeNode):
+            if self.layer.blending in {
+                Blending.TRANSLUCENT,
+                Blending.TRANSLUCENT_NO_DEPTH,
+            }:
+                self.node.mip_cutoff = self.node._texture.clim_normalized[0]
+                self.node.minip_cutoff = self.node._texture.clim_normalized[1]
+            else:
+                self.node.mip_cutoff = None
+                self.node.minip_cutoff = None
+
+    def _on_contrast_limits_change(self) -> None:
+        self.node.clim = self.layer.contrast_limits
+        # cutoffs must be updated after clims, so we can set them to the new values
+        self._update_mip_minip_cutoff()
+        # iso also may depend on contrast limit values
+        self._on_iso_threshold_change()
+
+    def _on_blending_change(self, event=None) -> None:
+        super()._on_blending_change()
+        # cutoffs must be updated after blending, so we can know if
+        # the new blending is a translucent one
+        self._update_mip_minip_cutoff()
+
+    def _on_gamma_change(self) -> None:
+        if len(self.node.shared_program.frag._set_items) > 0:
+            self.node.gamma = self.layer.gamma
+
+    def _on_iso_threshold_change(self) -> None:
+        if isinstance(self.node, VolumeNode):
+            if self.node._texture.is_normalized:
+                cmin, cmax = self.layer.contrast_limits_range
+                self.node.threshold = (self.layer.iso_threshold - cmin) / (
+                    cmax - cmin
+                )
+            else:
+                self.node.threshold = self.layer.iso_threshold
+
+    def _on_attenuation_change(self) -> None:
+        if isinstance(self.node, VolumeNode):
+            self.node.attenuation = self.layer.attenuation
+
+    def reset(self, event=None) -> None:
+        super().reset()
+        self._on_interpolation_change()
+        self._on_colormap_change()
+        self._on_contrast_limits_change()
+        self._on_gamma_change()
+
+
 _VISPY_FORMAT_TO_DTYPE: Dict[Optional[str], np.dtype] = {
     "r8": np.dtype(np.uint8),
     "r16": np.dtype(np.uint16),
diff --git a/napari/_vispy/layers/labels.py b/napari/_vispy/layers/labels.py
index d472cee4..726770e3 100644
--- a/napari/_vispy/layers/labels.py
+++ b/napari/_vispy/layers/labels.py
@@ -10,7 +10,7 @@ from napari._vispy.layers.image import (
     _DTYPE_TO_VISPY_FORMAT,
     _VISPY_FORMAT_TO_DTYPE,
     ImageLayerNode,
-    VispyImageLayer,
+    VispyScalarFieldBaseLayer,
     get_dtype_from_vispy_texture_format,
 )
 from napari._vispy.utils.gl import get_max_texture_sizes
@@ -192,7 +192,7 @@ def _select_colormap_texture(
     return color_texture.reshape(256, -1, 4)
 
 
-class VispyLabelsLayer(VispyImageLayer):
+class VispyLabelsLayer(VispyScalarFieldBaseLayer):
     layer: 'Labels'
 
     def __init__(self, layer, node=None, texture_format='r8') -> None:
@@ -220,8 +220,6 @@ class VispyLabelsLayer(VispyImageLayer):
                 if rendering != 'translucent'
                 else 'translucent_categorical'
             )
-            self._on_attenuation_change()
-            self._on_iso_threshold_change()
 
     def _on_colormap_change(self, event=None):
         # self.layer.colormap is a labels_colormap, which is an evented model
@@ -310,6 +308,10 @@ class VispyLabelsLayer(VispyImageLayer):
         )
         self.node.update()
 
+    def reset(self, event=None) -> None:
+        super().reset()
+        self._on_colormap_change()
+
 
 class LabelLayerNode(ImageLayerNode):
     def __init__(self, custom_node: Node = None, texture_format=None):
diff --git a/napari/components/viewer_model.py b/napari/components/viewer_model.py
index e40950cd..d651bb52 100644
--- a/napari/components/viewer_model.py
+++ b/napari/components/viewer_model.py
@@ -815,6 +815,9 @@ class ViewerModel(KeymapProvider, MousemapProvider, EventedModel):
             Properties defining plane rendering in 3D. Properties are defined in
             data coordinates. Valid dictionary keys are
             {'position', 'normal', 'thickness', and 'enabled'}.
+        projection_mode : str
+            How data outside the viewed dimensions but inside the thick Dims slice will
+            be projected onto the viewed dimensions. Must fit to cls._projectionclass
         experimental_clipping_planes : list of dicts, list of ClippingPlane, or ClippingPlaneList
             Each dict defines a clipping plane in 3D in data coordinates.
             Valid dictionary keys are {'position', 'normal', and 'enabled'}.
diff --git a/napari/layers/base/base.py b/napari/layers/base/base.py
index 9e7ec899..863edb7a 100644
--- a/napari/layers/base/base.py
+++ b/napari/layers/base/base.py
@@ -1,10 +1,11 @@
 from __future__ import annotations
 
 import copy
+import inspect
 import itertools
 import os.path
 import warnings
-from abc import ABC, abstractmethod
+from abc import ABC, ABCMeta, abstractmethod
 from collections import defaultdict, namedtuple
 from contextlib import contextmanager
 from functools import cached_property
@@ -76,8 +77,21 @@ def no_op(layer: Layer, event: Event) -> None:
     return
 
 
+class PostInit(ABCMeta):
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
+        sig = inspect.signature(self.__init__)
+        params = tuple(sig.parameters.values())
+        self.__signature__ = sig.replace(parameters=params[1:])
+
+    def __call__(self, *args, **kwargs):
+        obj = super().__call__(*args, **kwargs)
+        obj._post_init()
+        return obj
+
+
 @mgui.register_type(choices=get_layers, return_callback=add_layer_to_viewer)
-class Layer(KeymapProvider, MousemapProvider, ABC):
+class Layer(KeymapProvider, MousemapProvider, ABC, metaclass=PostInit):
     """Base layer class.
 
     Parameters
@@ -424,6 +438,9 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
         #       until we figure out nested evented objects
         self._overlays.events.connect(self.events._overlays)
 
+    def _post_init(self):
+        """Post init hook for subclasses to use."""
+
     def __str__(self):
         """Return self.name."""
         return self.name
@@ -748,7 +765,7 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
         """Update the dimensionality of transforms and slices when data changes."""
         ndim = self._get_ndim()
 
-        old_ndim = self._ndim
+        old_ndim = self._transforms['tile2data'].ndim
         if old_ndim > ndim:
             keep_axes = range(old_ndim - ndim, old_ndim)
             self._transforms = self._transforms.set_slice(keep_axes)
diff --git a/napari/layers/image/image.py b/napari/layers/image/image.py
index eca85d77..0bab70c6 100644
--- a/napari/layers/image/image.py
+++ b/napari/layers/image/image.py
@@ -4,7 +4,7 @@ from __future__ import annotations
 
 import types
 import warnings
-from typing import TYPE_CHECKING, List, Sequence, Tuple, Union
+from typing import TYPE_CHECKING, List, Tuple, Union
 
 import numpy as np
 from scipy import ndimage as ndi
@@ -46,7 +46,7 @@ if TYPE_CHECKING:
 # It is important to contain at least one abstractmethod to properly exclude this class
 # in creating NAMES set inside of napari.layers.__init__
 # Mixin must come before Layer
-class _ImageBase(IntensityVisualizationMixin, Layer):
+class _ImageBase(Layer):
     """Image layer.
 
     Parameters
@@ -58,70 +58,30 @@ class _ImageBase(IntensityVisualizationMixin, Layer):
         a multiscale image. Please note multiscale rendering is only
         supported in 2D. In 3D, only the lowest resolution scale is
         displayed.
-    rgb : bool
-        Whether the image is rgb RGB or RGBA. If not specified by user and
-        the last dimension of the data has length 3 or 4 it will be set as
-        `True`. If `False` the image is interpreted as a luminance image.
-    colormap : str, napari.utils.Colormap, tuple, dict
-        Colormap to use for luminance images. If a string must be the name
-        of a supported colormap from vispy or matplotlib. If a tuple the
-        first value must be a string to assign as a name to a colormap and
-        the second item must be a Colormap. If a dict the key must be a
-        string to assign as a name to a colormap and the value must be a
-        Colormap.
-    contrast_limits : list (2,)
-        Color limits to be used for determining the colormap bounds for
-        luminance images. If not passed is calculated as the min and max of
-        the image.
-    gamma : float
-        Gamma correction for determining colormap linearity. Defaults to 1.
-    interpolation : str
-        Interpolation mode used by vispy. Must be one of our supported modes.
-        'custom' is a special mode for 2D interpolation in which a regular grid
-        of samples are taken from the texture around a position using 'linear'
-        interpolation before being multiplied with a custom interpolation kernel
-        (provided with 'custom_interpolation_kernel_2d').
-    rendering : str
-        Rendering mode used by vispy. Must be one of our supported
-        modes.
-    depiction : str
-        3D Depiction mode. Must be one of {'volume', 'plane'}.
-        The default value is 'volume'.
-    iso_threshold : float
-        Threshold for isosurface.
-    attenuation : float
-        Attenuation rate for attenuated maximum intensity projection.
-    name : str
-        Name of the layer.
-    metadata : dict
-        Layer metadata.
-    scale : tuple of float
-        Scale factors for the layer.
-    translate : tuple of float
-        Translation values for the layer.
-    rotate : float, 3-tuple of float, or n-D array.
-        If a float convert into a 2D rotation matrix using that value as an
-        angle. If 3-tuple convert into a 3D rotation matrix, using a yaw,
-        pitch, roll convention. Otherwise assume an nD rotation. Angles are
-        assumed to be in degrees. They can be converted from radians with
-        np.degrees if needed.
-    shear : 1-D array or n-D array
-        Either a vector of upper triangular values, or an nD shear matrix with
-        ones along the main diagonal.
     affine : n-D array or napari.utils.transforms.Affine
         (N+1, N+1) affine transformation matrix in homogeneous coordinates.
         The first (N, N) entries correspond to a linear transform and
         the final column is a length N translation vector and a 1 or a napari
         `Affine` transform object. Applied as an extra transform on top of the
         provided scale, rotate, and shear values.
-    opacity : float
-        Opacity of the layer visual, between 0.0 and 1.0.
     blending : str
         One of a list of preset blending modes that determines how RGB and
         alpha values of the layer visual get mixed. Allowed values are
         {'opaque', 'translucent', and 'additive'}.
-    visible : bool
-        Whether the layer visual is currently being displayed.
+    cache : bool
+        Whether slices of out-of-core datasets should be cached upon retrieval.
+        Currently, this only applies to dask arrays.
+    custom_interpolation_kernel_2d : np.ndarray
+        Convolution kernel used with the 'custom' interpolation mode in 2D rendering.
+    depiction : str
+        3D Depiction mode. Must be one of {'volume', 'plane'}.
+        The default value is 'volume'.
+    experimental_clipping_planes : list of dicts, list of ClippingPlane, or ClippingPlaneList
+        Each dict defines a clipping plane in 3D in data coordinates.
+        Valid dictionary keys are {'position', 'normal', and 'enabled'}.
+        Values on the negative side of the normal are discarded if the plane is enabled.
+    metadata : dict
+        Layer metadata.
     multiscale : bool
         Whether the data is a multiscale image or not. Multiscale data is
         represented by a list of array like image data. If not specified by
@@ -130,19 +90,35 @@ class _ImageBase(IntensityVisualizationMixin, Layer):
         should be the largest. Please note multiscale rendering is only
         supported in 2D. In 3D, only the lowest resolution scale is
         displayed.
-    cache : bool
-        Whether slices of out-of-core datasets should be cached upon retrieval.
-        Currently, this only applies to dask arrays.
+    name : str
+        Name of the layer.
+    ndim : int
+        Number of dimensions in the data.
+    opacity : float
+        Opacity of the layer visual, between 0.0 and 1.0.
     plane : dict or SlicingPlane
         Properties defining plane rendering in 3D. Properties are defined in
         data coordinates. Valid dictionary keys are
         {'position', 'normal', 'thickness', and 'enabled'}.
-    experimental_clipping_planes : list of dicts, list of ClippingPlane, or ClippingPlaneList
-        Each dict defines a clipping plane in 3D in data coordinates.
-        Valid dictionary keys are {'position', 'normal', and 'enabled'}.
-        Values on the negative side of the normal are discarded if the plane is enabled.
-    custom_interpolation_kernel_2d : np.ndarray
-        Convolution kernel used with the 'custom' interpolation mode in 2D rendering.
+    rendering : str
+        Rendering mode used by vispy. Must be one of our supported
+        modes.
+    rotate : float, 3-tuple of float, or n-D array.
+        If a float convert into a 2D rotation matrix using that value as an
+        angle. If 3-tuple convert into a 3D rotation matrix, using a yaw,
+        pitch, roll convention. Otherwise assume an nD rotation. Angles are
+        assumed to be in degrees. They can be converted from radians with
+        np.degrees if needed.
+    scale : tuple of float
+        Scale factors for the layer.
+    shear : 1-D array or n-D array
+        Either a vector of upper triangular values, or an nD shear matrix with
+        ones along the main diagonal.
+    translate : tuple of float
+        Translation values for the layer.
+    visible : bool
+        Whether the layer visual is currently being displayed.
+
 
     Attributes
     ----------
@@ -155,11 +131,6 @@ class _ImageBase(IntensityVisualizationMixin, Layer):
         displayed.
     metadata : dict
         Image metadata.
-    rgb : bool
-        Whether the image is rgb RGB or RGBA if rgb. If not
-        specified by user and the last dimension of the data has length 3 or 4
-        it will be set as `True`. If `False` the image is interpreted as a
-        luminance image.
     multiscale : bool
         Whether the data is a multiscale image or not. Multiscale data is
         represented by a list of array like image data. The first image in the
@@ -171,35 +142,11 @@ class _ImageBase(IntensityVisualizationMixin, Layer):
         allows for normal interactivity with the canvas.
 
         In TRANSFORM mode the image can be transformed interactively.
-    colormap : 2-tuple of str, napari.utils.Colormap
-        The first is the name of the current colormap, and the second value is
-        the colormap. Colormaps are used for luminance images, if the image is
-        rgb the colormap is ignored.
-    colormaps : tuple of str
-        Names of the available colormaps.
-    contrast_limits : list (2,) of float
-        Color limits to be used for determining the colormap bounds for
-        luminance images. If the image is rgb the contrast_limits is ignored.
-    contrast_limits_range : list (2,) of float
-        Range for the color limits for luminance images. If the image is
-        rgb the contrast_limits_range is ignored.
-    gamma : float
-        Gamma correction for determining colormap linearity.
-    interpolation : str
-        Interpolation mode used by vispy. Must be one of our supported modes.
-        'custom' is a special mode for 2D interpolation in which a regular grid
-        of samples are taken from the texture around a position using 'linear'
-        interpolation before being multiplied with a custom interpolation kernel
-        (provided with 'custom_interpolation_kernel_2d').
     rendering : str
         Rendering mode used by vispy. Must be one of our supported
         modes.
     depiction : str
         3D Depiction mode used by vispy. Must be one of our supported modes.
-    iso_threshold : float
-        Threshold for isosurface.
-    attenuation : float
-        Attenuation rate for attenuated maximum intensity projection.
     plane : SlicingPlane or dict
         Properties defining plane rendering in 3D. Valid dictionary keys are
         {'position', 'normal', 'thickness'}.
@@ -220,41 +167,28 @@ class _ImageBase(IntensityVisualizationMixin, Layer):
 
     _colormaps = AVAILABLE_COLORMAPS
 
-    @rename_argument(
-        from_name="interpolation",
-        to_name="interpolation2d",
-        version="0.6.0",
-        since_version="0.4.17",
-    )
     def __init__(
         self,
         data,
         *,
-        rgb=None,
-        colormap='gray',
-        contrast_limits=None,
-        gamma=1,
-        interpolation2d='nearest',
-        interpolation3d='linear',
-        rendering='mip',
-        iso_threshold=None,
-        attenuation=0.05,
-        name=None,
-        metadata=None,
-        scale=None,
-        translate=None,
-        rotate=None,
-        shear=None,
         affine=None,
-        opacity=1,
         blending='translucent',
-        visible=True,
-        multiscale=None,
         cache=True,
+        custom_interpolation_kernel_2d=None,
         depiction='volume',
-        plane=None,
         experimental_clipping_planes=None,
-        custom_interpolation_kernel_2d=None,
+        metadata=None,
+        multiscale=None,
+        name=None,
+        ndim=None,
+        opacity=1.0,
+        plane=None,
+        rendering='mip',
+        rotate=None,
+        scale=None,
+        shear=None,
+        translate=None,
+        visible=True,
     ) -> None:
         if name is None and data is not None:
             name = magic_name(data)
@@ -274,22 +208,9 @@ class _ImageBase(IntensityVisualizationMixin, Layer):
         elif multiscale and not isinstance(data, MultiScaleData):
             data = MultiScaleData(data)
 
-        # Determine if rgb
-        rgb_guess = guess_rgb(data.shape)
-        if rgb and not rgb_guess:
-            raise ValueError(
-                trans._(
-                    "'rgb' was set to True but data does not have suitable dimensions."
-                )
-            )
-        if rgb is None:
-            rgb = rgb_guess
-        self.rgb = rgb
-
         # Determine dimensionality of the data
-        ndim = len(data.shape)
-        if rgb:
-            ndim -= 1
+        if ndim is None:
+            ndim = len(data.shape)
 
         super().__init__(
             data,
@@ -310,6 +231,9 @@ class _ImageBase(IntensityVisualizationMixin, Layer):
         )
 
         self.events.add(
+            attenuation=Event,
+            custom_interpolation_kernel_2d=Event,
+            depiction=Event,
             interpolation=WarningEmitter(
                 trans._(
                     "'layer.events.interpolation' is deprecated please use `interpolation2d` and `interpolation3d`",
@@ -319,12 +243,9 @@ class _ImageBase(IntensityVisualizationMixin, Layer):
             ),
             interpolation2d=Event,
             interpolation3d=Event,
-            rendering=Event,
-            plane=Event,
-            depiction=Event,
             iso_threshold=Event,
-            attenuation=Event,
-            custom_interpolation_kernel_2d=Event,
+            plane=Event,
+            rendering=Event,
         )
 
         self._array_like = True
@@ -354,41 +275,14 @@ class _ImageBase(IntensityVisualizationMixin, Layer):
 
         self._new_empty_slice()
 
-        # Set contrast limits, colormaps and plane parameters
-        self._gamma = gamma
-        self._attenuation = attenuation
-        self._plane = SlicingPlane(thickness=1, enabled=False, draggable=True)
+        self._plane = SlicingPlane(thickness=1)
         # Whether to calculate clims on the next set_view_slice
         self._should_calc_clims = False
-        if contrast_limits is None:
-            if not isinstance(data, np.ndarray):
-                dtype = normalize_dtype(getattr(data, 'dtype', None))
-                if np.issubdtype(dtype, np.integer):
-                    self.contrast_limits_range = get_dtype_limits(dtype)
-                else:
-                    self.contrast_limits_range = (0, 1)
-                self._should_calc_clims = dtype != np.uint8
-            else:
-                self.contrast_limits_range = self._calc_data_range()
-        else:
-            self.contrast_limits_range = contrast_limits
-        self._contrast_limits = tuple(self.contrast_limits_range)
-        if iso_threshold is None:
-            cmin, cmax = self.contrast_limits_range
-            self._iso_threshold = cmin + (cmax - cmin) / 2
-        else:
-            self._iso_threshold = iso_threshold
         # using self.colormap = colormap uses the setter in *derived* classes,
         # where the intention here is to use the base setter, so we use the
         # _set_colormap method. This is important for Labels layers, because
         # we don't want to use get_color before set_view_slice has been
         # triggered (self.refresh(), below).
-        self._colormap = ensure_colormap(colormap)
-        self.contrast_limits = self._contrast_limits
-        self._interpolation2d = Interpolation.NEAREST
-        self._interpolation3d = Interpolation.NEAREST
-        self.interpolation2d = interpolation2d
-        self.interpolation3d = interpolation3d
         self.rendering = rendering
         self.depiction = depiction
         if plane is not None:
@@ -396,6 +290,7 @@ class _ImageBase(IntensityVisualizationMixin, Layer):
         connect_no_arg(self.plane.events, self.events, 'plane')
         self.custom_interpolation_kernel_2d = custom_interpolation_kernel_2d
 
+    def _post_init(self):
         # Trigger generation of view slice and thumbnail
         self.refresh()
 
@@ -403,13 +298,15 @@ class _ImageBase(IntensityVisualizationMixin, Layer):
         """Initialize the current slice to an empty image."""
         wrapper = _weakref_hide(self)
         self._slice = ImageSlice(
-            self._get_empty_image(), wrapper._raw_to_displayed, self.rgb
+            self._get_empty_image(),
+            wrapper._raw_to_displayed,
+            len(self.data.shape) != self.ndim,
         )
         self._empty = True
 
     def _get_empty_image(self):
         """Get empty image to use as the default before data is loaded."""
-        if self.rgb:
+        if len(self.data.shape) != self.ndim:
             return np.zeros(
                 (1,) * self._slice_input.ndisplay + (3,), dtype=np.uint8
             )
@@ -419,7 +316,7 @@ class _ImageBase(IntensityVisualizationMixin, Layer):
     def _get_order(self) -> Tuple[int]:
         """Return the ordered displayed dimensions, but reduced to fit in the slice space."""
         order = reorder_after_dim_reduction(self._slice_input.displayed)
-        if self.rgb:
+        if len(self.data.shape) != self.ndim:
             # if rgb need to keep the final axis fixed during the
             # transpose. The index of the final axis depends on how many
             # axes are displayed.
@@ -432,26 +329,6 @@ class _ImageBase(IntensityVisualizationMixin, Layer):
         """Viewable image for the current slice. (compatibility)"""
         return self._slice.image.view
 
-    def _calc_data_range(self, mode='data'):
-        """
-        Calculate the range of the data values in the currently viewed slice
-        or full data array
-        """
-        if mode == 'data':
-            input_data = self.data[-1] if self.multiscale else self.data
-        elif mode == 'slice':
-            data = self._slice.image.view  # ugh
-            input_data = data[-1] if self.multiscale else data
-        else:
-            raise ValueError(
-                trans._(
-                    "mode must be either 'data' or 'slice', got {mode!r}",
-                    deferred=True,
-                    mode=mode,
-                )
-            )
-        return calc_data_range(input_data, rgb=self.rgb)
-
     @property
     def dtype(self):
         return self._data.dtype
@@ -461,24 +338,6 @@ class _ImageBase(IntensityVisualizationMixin, Layer):
         """Data, exactly as provided by the user."""
         return self._data_raw
 
-    @property
-    def data(self) -> LayerDataProtocol:
-        """Data, possibly in multiscale wrapper. Obeys LayerDataProtocol."""
-        return self._data
-
-    @data.setter
-    def data(
-        self, data: Union[LayerDataProtocol, Sequence[LayerDataProtocol]]
-    ):
-        self._data_raw = data
-        # note, we don't support changing multiscale in an Image instance
-        self._data = MultiScaleData(data) if self.multiscale else data  # type: ignore
-        self._update_dims()
-        self.events.data(value=self.data)
-        if self._keep_auto_contrast:
-            self.reset_contrast_limits()
-        self._reset_editable()
-
     def _get_ndim(self):
         """Determine number of dimensions of the layer."""
         return len(self.level_shapes[0])
@@ -527,13 +386,18 @@ class _ImageBase(IntensityVisualizationMixin, Layer):
         self._data_level = level
         self.refresh()
 
+    def _get_level_shapes(self):
+        data = self.data
+        if isinstance(data, MultiScaleData):
+            shapes = data.shapes
+        else:
+            shapes = [self.data.shape]
+        return shapes
+
     @property
     def level_shapes(self):
         """array: Shapes of each level of the multiscale or just of image."""
-        shapes = self.data.shapes if self.multiscale else [self.data.shape]
-        if self.rgb:
-            shapes = [s[:-1] for s in shapes]
-        return np.array(shapes)
+        return np.array(self._get_level_shapes())
 
     @property
     def downsample_factors(self):
@@ -541,131 +405,8 @@ class _ImageBase(IntensityVisualizationMixin, Layer):
         return np.divide(self.level_shapes[0], self.level_shapes)
 
     @property
-    def iso_threshold(self):
-        """float: threshold for isosurface."""
-        return self._iso_threshold
-
-    @iso_threshold.setter
-    def iso_threshold(self, value):
-        self._iso_threshold = value
-        self._update_thumbnail()
-        self.events.iso_threshold()
-
-    @property
-    def attenuation(self):
-        """float: attenuation rate for attenuated_mip rendering."""
-        return self._attenuation
-
-    @attenuation.setter
-    def attenuation(self, value):
-        self._attenuation = value
-        self._update_thumbnail()
-        self.events.attenuation()
-
-    @property
-    def interpolation(self):
-        """Return current interpolation mode.
-
-        Selects a preset interpolation mode in vispy that determines how volume
-        is displayed.  Makes use of the two Texture2D interpolation methods and
-        the available interpolation methods defined in
-        vispy/gloo/glsl/misc/spatial_filters.frag
-
-        Options include:
-        'bessel', 'cubic', 'linear', 'blackman', 'catrom', 'gaussian',
-        'hamming', 'hanning', 'hermite', 'kaiser', 'lanczos', 'mitchell',
-        'nearest', 'spline16', 'spline36'
-
-        Returns
-        -------
-        str
-            The current interpolation mode
-        """
-        warnings.warn(
-            trans._(
-                "Interpolation attribute is deprecated since 0.4.17. Please use interpolation2d or interpolation3d",
-            ),
-            category=DeprecationWarning,
-            stacklevel=2,
-        )
-        return str(
-            self._interpolation2d
-            if self._slice_input.ndisplay == 2
-            else self._interpolation3d
-        )
-
-    @interpolation.setter
-    def interpolation(self, interpolation):
-        """Set current interpolation mode."""
-        warnings.warn(
-            trans._(
-                "Interpolation setting is deprecated since 0.4.17. Please use interpolation2d or interpolation3d",
-            ),
-            category=DeprecationWarning,
-            stacklevel=2,
-        )
-        if self._slice_input.ndisplay == 3:
-            self.interpolation3d = interpolation
-        else:
-            if interpolation == 'bilinear':
-                interpolation = 'linear'
-                warnings.warn(
-                    trans._(
-                        "'bilinear' is invalid for interpolation2d (introduced in napari 0.4.17). "
-                        "Please use 'linear' instead, and please set directly the 'interpolation2d' attribute'.",
-                    ),
-                    category=DeprecationWarning,
-                    stacklevel=2,
-                )
-            self.interpolation2d = interpolation
-
-    @property
-    def interpolation2d(self):
-        return str(self._interpolation2d)
-
-    @interpolation2d.setter
-    def interpolation2d(self, value):
-        if value == 'bilinear':
-            raise ValueError(
-                trans._(
-                    "'bilinear' interpolation is not valid for interpolation2d. Did you mean 'linear' instead ?",
-                ),
-            )
-        if value == 'bicubic':
-            value = 'cubic'
-            warnings.warn(
-                trans._("'bicubic' is deprecated. Please use 'cubic' instead"),
-                category=DeprecationWarning,
-                stacklevel=2,
-            )
-        self._interpolation2d = Interpolation(value)
-        self.events.interpolation2d(value=self._interpolation2d)
-        self.events.interpolation(value=self._interpolation2d)
-
-    @property
-    def interpolation3d(self):
-        return str(self._interpolation3d)
-
-    @interpolation3d.setter
-    def interpolation3d(self, value):
-        if value == 'custom':
-            raise NotImplementedError(
-                'custom interpolation is not implemented yet for 3D rendering'
-            )
-        if value == 'bicubic':
-            value = 'cubic'
-            warnings.warn(
-                trans._("'bicubic' is deprecated. Please use 'cubic' instead"),
-                category=DeprecationWarning,
-                stacklevel=2,
-            )
-        self._interpolation3d = Interpolation(value)
-        self.events.interpolation3d(value=self._interpolation3d)
-        self.events.interpolation(value=self._interpolation3d)
-
-    @property
-    def depiction(self):
-        """The current 3D depiction mode.
+    def depiction(self):
+        """The current 3D depiction mode.
 
         Selects a preset depiction mode in vispy
             * volume: images are rendered as 3D volumes.
@@ -856,12 +597,6 @@ class _ImageBase(IntensityVisualizationMixin, Layer):
             self, image_indices, image, thumbnail_source
         )
         self._load_slice(data)
-        if self._should_calc_clims:
-            self.reset_contrast_limits_range()
-            self.reset_contrast_limits()
-            self._should_calc_clims = False
-        elif self._keep_auto_contrast:
-            self.reset_contrast_limits()
 
     @property
     def _SliceDataClass(self):
@@ -959,7 +694,7 @@ class _ImageBase(IntensityVisualizationMixin, Layer):
             self._thumbnail_shape[:2],
         )
         zoom_factor = tuple(new_shape / image.shape[:2])
-        if self.rgb:
+        if len(self.data.shape) != self.ndim:
             downsampled = ndi.zoom(
                 image, zoom_factor + (1,), prefilter=False, order=0
             )
@@ -1016,7 +751,9 @@ class _ImageBase(IntensityVisualizationMixin, Layer):
         coord = np.round(coord).astype(int)
 
         raw = self._slice.image.raw
-        shape = raw.shape[:-1] if self.rgb else raw.shape
+        shape = (
+            raw.shape[:-1] if len(self.data.shape) != self.ndim else raw.shape
+        )
 
         if self.ndim < len(coord):
             # handle 3D views of 2D data by omitting extra coordinate
@@ -1078,48 +815,325 @@ class _ImageBase(IntensityVisualizationMixin, Layer):
             self._on_data_loaded(data, sync=False)
 
 
-class Image(_ImageBase):
-    @property
-    def rendering(self):
-        """Return current rendering mode.
-
-        Selects a preset rendering mode in vispy that determines how
-        volume is displayed.  Options include:
-
-        * ``translucent``: voxel colors are blended along the view ray until
-            the result is opaque.
-        * ``mip``: maximum intensity projection. Cast a ray and display the
-            maximum value that was encountered.
-        * ``minip``: minimum intensity projection. Cast a ray and display the
-            minimum value that was encountered.
-        * ``attenuated_mip``: attenuated maximum intensity projection. Cast a
-            ray and attenuate values based on integral of encountered values,
-            display the maximum value that was encountered after attenuation.
-            This will make nearer objects appear more prominent.
-        * ``additive``: voxel colors are added along the view ray until
-            the result is saturated.
-        * ``iso``: isosurface. Cast a ray until a certain threshold is
-            encountered. At that location, lighning calculations are
-            performed to give the visual appearance of a surface.
-        * ``average``: average intensity projection. Cast a ray and display the
-            average of values that were encountered.
-
-        Returns
-        -------
-        str
-            The current rendering mode
-        """
-        return str(self._rendering)
-
-    @rendering.setter
-    def rendering(self, rendering):
-        self._rendering = ImageRendering(rendering)
-        self.events.rendering()
+class Image(IntensityVisualizationMixin, _ImageBase):
+    """Image layer.
 
-    def _get_state(self):
-        """Get dictionary of layer state.
+    Parameters
+    ----------
+    data : array or list of array
+        Image data. Can be N >= 2 dimensional. If the last dimension has length
+        3 or 4 can be interpreted as RGB or RGBA if rgb is `True`. If a
+        list and arrays are decreasing in shape then the data is treated as
+        a multiscale image. Please note multiscale rendering is only
+        supported in 2D. In 3D, only the lowest resolution scale is
+        displayed.
+    affine : n-D array or napari.utils.transforms.Affine
+        (N+1, N+1) affine transformation matrix in homogeneous coordinates.
+        The first (N, N) entries correspond to a linear transform and
+        the final column is a length N translation vector and a 1 or a napari
+        `Affine` transform object. Applied as an extra transform on top of the
+        provided scale, rotate, and shear values.
+    attenuation : float
+        Attenuation rate for attenuated maximum intensity projection.
+    blending : str
+        One of a list of preset blending modes that determines how RGB and
+        alpha values of the layer visual get mixed. Allowed values are
+        {'opaque', 'translucent', and 'additive'}.
+    cache : bool
+        Whether slices of out-of-core datasets should be cached upon retrieval.
+        Currently, this only applies to dask arrays.
+    colormap : str, napari.utils.Colormap, tuple, dict
+        Colormap to use for luminance images. If a string must be the name
+        of a supported colormap from vispy or matplotlib. If a tuple the
+        first value must be a string to assign as a name to a colormap and
+        the second item must be a Colormap. If a dict the key must be a
+        string to assign as a name to a colormap and the value must be a
+        Colormap.
+    contrast_limits : list (2,)
+        Color limits to be used for determining the colormap bounds for
+        luminance images. If not passed is calculated as the min and max of
+        the image.
+    custom_interpolation_kernel_2d : np.ndarray
+        Convolution kernel used with the 'custom' interpolation mode in 2D rendering.
+    depiction : str
+        3D Depiction mode. Must be one of {'volume', 'plane'}.
+        The default value is 'volume'.
+    experimental_clipping_planes : list of dicts, list of ClippingPlane, or ClippingPlaneList
+        Each dict defines a clipping plane in 3D in data coordinates.
+        Valid dictionary keys are {'position', 'normal', and 'enabled'}.
+        Values on the negative side of the normal are discarded if the plane is enabled.
+    gamma : float
+        Gamma correction for determining colormap linearity. Defaults to 1.
+    interpolation2d : str
+        Interpolation mode used by vispy for rendering 2d data.
+        Must be one of our supported modes.
+        (for list of supported modes see Interpolation enum)
+        'custom' is a special mode for 2D interpolation in which a regular grid
+        of samples are taken from the texture around a position using 'linear'
+        interpolation before being multiplied with a custom interpolation kernel
+        (provided with 'custom_interpolation_kernel_2d').
+    interpolation3d : str
+        Same as 'interpolation2d' but for 3D rendering.
+    iso_threshold : float
+        Threshold for isosurface.
+    metadata : dict
+        Layer metadata.
+    multiscale : bool
+        Whether the data is a multiscale image or not. Multiscale data is
+        represented by a list of array like image data. If not specified by
+        the user and if the data is a list of arrays that decrease in shape
+        then it will be taken to be multiscale. The first image in the list
+        should be the largest. Please note multiscale rendering is only
+        supported in 2D. In 3D, only the lowest resolution scale is
+        displayed.
+    name : str
+        Name of the layer.
+    opacity : float
+        Opacity of the layer visual, between 0.0 and 1.0.
+    plane : dict or SlicingPlane
+        Properties defining plane rendering in 3D. Properties are defined in
+        data coordinates. Valid dictionary keys are
+        {'position', 'normal', 'thickness', and 'enabled'}.
+    rendering : str
+        Rendering mode used by vispy. Must be one of our supported
+        modes.
+    rgb : bool
+        Whether the image is rgb RGB or RGBA. If not specified by user and
+        the last dimension of the data has length 3 or 4 it will be set as
+        `True`. If `False` the image is interpreted as a luminance image.
+    rotate : float, 3-tuple of float, or n-D array.
+        If a float convert into a 2D rotation matrix using that value as an
+        angle. If 3-tuple convert into a 3D rotation matrix, using a yaw,
+        pitch, roll convention. Otherwise assume an nD rotation. Angles are
+        assumed to be in degrees. They can be converted from radians with
+        np.degrees if needed.
+    scale : tuple of float
+        Scale factors for the layer.
+    shear : 1-D array or n-D array
+        Either a vector of upper triangular values, or an nD shear matrix with
+        ones along the main diagonal.
+    translate : tuple of float
+        Translation values for the layer.
+    visible : bool
+        Whether the layer visual is currently being displayed.
 
-        Returns
+    Attributes
+    ----------
+    data : array or list of array
+        Image data. Can be N dimensional. If the last dimension has length
+        3 or 4 can be interpreted as RGB or RGBA if rgb is `True`. If a list
+        and arrays are decreasing in shape then the data is treated as a
+        multiscale image. Please note multiscale rendering is only
+        supported in 2D. In 3D, only the lowest resolution scale is
+        displayed.
+    metadata : dict
+        Image metadata.
+    rgb : bool
+        Whether the image is rgb RGB or RGBA if rgb. If not
+        specified by user and the last dimension of the data has length 3 or 4
+        it will be set as `True`. If `False` the image is interpreted as a
+        luminance image.
+    multiscale : bool
+        Whether the data is a multiscale image or not. Multiscale data is
+        represented by a list of array like image data. The first image in the
+        list should be the largest. Please note multiscale rendering is only
+        supported in 2D. In 3D, only the lowest resolution scale is
+        displayed.
+    mode : str
+        Interactive mode. The normal, default mode is PAN_ZOOM, which
+        allows for normal interactivity with the canvas.
+
+        In TRANSFORM mode the image can be transformed interactively.
+    colormap : 2-tuple of str, napari.utils.Colormap
+        The first is the name of the current colormap, and the second value is
+        the colormap. Colormaps are used for luminance images, if the image is
+        rgb the colormap is ignored.
+    colormaps : tuple of str
+        Names of the available colormaps.
+    contrast_limits : list (2,) of float
+        Color limits to be used for determining the colormap bounds for
+        luminance images. If the image is rgb the contrast_limits is ignored.
+    contrast_limits_range : list (2,) of float
+        Range for the color limits for luminance images. If the image is
+        rgb the contrast_limits_range is ignored.
+    gamma : float
+        Gamma correction for determining colormap linearity.
+    interpolation2d : str
+        Interpolation mode used by vispy. Must be one of our supported modes.
+        'custom' is a special mode for 2D interpolation in which a regular grid
+        of samples are taken from the texture around a position using 'linear'
+        interpolation before being multiplied with a custom interpolation kernel
+        (provided with 'custom_interpolation_kernel_2d').
+    interpolation3d : str
+        Same as 'interpolation2d' but for 3D rendering.
+    rendering : str
+        Rendering mode used by vispy. Must be one of our supported
+        modes.
+    depiction : str
+        3D Depiction mode used by vispy. Must be one of our supported modes.
+    iso_threshold : float
+        Threshold for isosurface.
+    attenuation : float
+        Attenuation rate for attenuated maximum intensity projection.
+    plane : SlicingPlane or dict
+        Properties defining plane rendering in 3D. Valid dictionary keys are
+        {'position', 'normal', 'thickness'}.
+    experimental_clipping_planes : ClippingPlaneList
+        Clipping planes defined in data coordinates, used to clip the volume.
+    custom_interpolation_kernel_2d : np.ndarray
+        Convolution kernel used with the 'custom' interpolation mode in 2D rendering.
+
+    Notes
+    -----
+    _data_view : array (N, M), (N, M, 3), or (N, M, 4)
+        Image data for the currently viewed slice. Must be 2D image data, but
+        can be multidimensional for RGB or RGBA images if multidimensional is
+        `True`.
+    """
+
+    @rename_argument(
+        from_name="interpolation",
+        to_name="interpolation2d",
+        version="0.6.0",
+        since_version="0.4.17",
+    )
+    def __init__(
+        self,
+        data,
+        *,
+        affine=None,
+        attenuation=0.05,
+        blending='translucent',
+        cache=True,
+        colormap='gray',
+        contrast_limits=None,
+        custom_interpolation_kernel_2d=None,
+        depiction='volume',
+        experimental_clipping_planes=None,
+        gamma=1.0,
+        interpolation2d='nearest',
+        interpolation3d='linear',
+        iso_threshold=None,
+        metadata=None,
+        multiscale=None,
+        name=None,
+        opacity=1.0,
+        plane=None,
+        rendering='mip',
+        rgb=None,
+        rotate=None,
+        scale=None,
+        shear=None,
+        translate=None,
+        visible=True,
+    ) -> None:
+        # Determine if rgb
+        data_shape = data.shape if hasattr(data, 'shape') else data[0].shape
+        rgb_guess = guess_rgb(data_shape)
+        if rgb and not rgb_guess:
+            raise ValueError(
+                trans._(
+                    "'rgb' was set to True but data does not have suitable dimensions."
+                )
+            )
+        if rgb is None:
+            rgb = rgb_guess
+
+        self.rgb = rgb
+        super().__init__(
+            data,
+            affine=affine,
+            blending=blending,
+            cache=cache,
+            custom_interpolation_kernel_2d=custom_interpolation_kernel_2d,
+            depiction=depiction,
+            experimental_clipping_planes=experimental_clipping_planes,
+            metadata=metadata,
+            multiscale=multiscale,
+            name=name,
+            ndim=len(data_shape) - 1 if rgb else len(data_shape),
+            opacity=opacity,
+            plane=plane,
+            rendering=rendering,
+            rotate=rotate,
+            scale=scale,
+            shear=shear,
+            translate=translate,
+            visible=visible,
+        )
+
+        self.rgb = rgb
+        self._colormap = ensure_colormap(colormap)
+        self._gamma = gamma
+        self._interpolation2d = Interpolation.NEAREST
+        self._interpolation3d = Interpolation.NEAREST
+        self.interpolation2d = interpolation2d
+        self.interpolation3d = interpolation3d
+        self._attenuation = attenuation
+
+        # Set contrast limits, colormaps and plane parameters
+        if contrast_limits is None:
+            if not isinstance(data, np.ndarray):
+                dtype = normalize_dtype(getattr(data, 'dtype', None))
+                if np.issubdtype(dtype, np.integer):
+                    self.contrast_limits_range = get_dtype_limits(dtype)
+                else:
+                    self.contrast_limits_range = (0, 1)
+                self._should_calc_clims = dtype != np.uint8
+            else:
+                self.contrast_limits_range = self._calc_data_range()
+        else:
+            self.contrast_limits_range = contrast_limits
+        self._contrast_limits: Tuple[float, float] = self.contrast_limits_range
+        self.contrast_limits = self._contrast_limits
+
+        if iso_threshold is None:
+            cmin, cmax = self.contrast_limits_range
+            self._iso_threshold = cmin + (cmax - cmin) / 2
+        else:
+            self._iso_threshold = iso_threshold
+
+    @property
+    def rendering(self):
+        """Return current rendering mode.
+
+        Selects a preset rendering mode in vispy that determines how
+        volume is displayed.  Options include:
+
+        * ``translucent``: voxel colors are blended along the view ray until
+            the result is opaque.
+        * ``mip``: maximum intensity projection. Cast a ray and display the
+            maximum value that was encountered.
+        * ``minip``: minimum intensity projection. Cast a ray and display the
+            minimum value that was encountered.
+        * ``attenuated_mip``: attenuated maximum intensity projection. Cast a
+            ray and attenuate values based on integral of encountered values,
+            display the maximum value that was encountered after attenuation.
+            This will make nearer objects appear more prominent.
+        * ``additive``: voxel colors are added along the view ray until
+            the result is saturated.
+        * ``iso``: isosurface. Cast a ray until a certain threshold is
+            encountered. At that location, lighning calculations are
+            performed to give the visual appearance of a surface.
+        * ``average``: average intensity projection. Cast a ray and display the
+            average of values that were encountered.
+
+        Returns
+        -------
+        str
+            The current rendering mode
+        """
+        return str(self._rendering)
+
+    @rendering.setter
+    def rendering(self, rendering):
+        self._rendering = ImageRendering(rendering)
+        self.events.rendering()
+
+    def _get_state(self):
+        """Get dictionary of layer state.
+
+        Returns
         -------
         state : dict
             Dictionary of layer state.
@@ -1145,6 +1159,235 @@ class Image(_ImageBase):
         )
         return state
 
+    @property
+    def attenuation(self) -> float:
+        """float: attenuation rate for attenuated_mip rendering."""
+        return self._attenuation
+
+    @attenuation.setter
+    def attenuation(self, value: float):
+        self._attenuation = value
+        self._update_thumbnail()
+        self.events.attenuation()
+
+    @property
+    def data(self) -> LayerDataProtocol:
+        """Data, possibly in multiscale wrapper. Obeys LayerDataProtocol."""
+        return self._data
+
+    @data.setter
+    def data(self, data: Union[LayerDataProtocol, MultiScaleData]):
+        self._data_raw = data
+        # note, we don't support changing multiscale in an Image instance
+        self._data = MultiScaleData(data) if self.multiscale else data  # type: ignore
+        self._update_dims()
+        self.events.data(value=self.data)
+        if self._keep_auto_contrast:
+            self.reset_contrast_limits()
+        self._reset_editable()
+
+    @property
+    def interpolation(self):
+        """Return current interpolation mode.
+
+        Selects a preset interpolation mode in vispy that determines how volume
+        is displayed.  Makes use of the two Texture2D interpolation methods and
+        the available interpolation methods defined in
+        vispy/gloo/glsl/misc/spatial_filters.frag
+
+        Options include:
+        'bessel', 'cubic', 'linear', 'blackman', 'catrom', 'gaussian',
+        'hamming', 'hanning', 'hermite', 'kaiser', 'lanczos', 'mitchell',
+        'nearest', 'spline16', 'spline36'
+
+        Returns
+        -------
+        str
+            The current interpolation mode
+        """
+        warnings.warn(
+            trans._(
+                "Interpolation attribute is deprecated since 0.4.17. Please use interpolation2d or interpolation3d",
+            ),
+            category=DeprecationWarning,
+            stacklevel=2,
+        )
+        return str(
+            self._interpolation2d
+            if self._slice_input.ndisplay == 2
+            else self._interpolation3d
+        )
+
+    @interpolation.setter
+    def interpolation(self, interpolation):
+        """Set current interpolation mode."""
+        warnings.warn(
+            trans._(
+                "Interpolation setting is deprecated since 0.4.17. Please use interpolation2d or interpolation3d",
+            ),
+            category=DeprecationWarning,
+            stacklevel=2,
+        )
+        if self._slice_input.ndisplay == 3:
+            self.interpolation3d = interpolation
+        else:
+            if interpolation == 'bilinear':
+                interpolation = 'linear'
+                warnings.warn(
+                    trans._(
+                        "'bilinear' is invalid for interpolation2d (introduced in napari 0.4.17). "
+                        "Please use 'linear' instead, and please set directly the 'interpolation2d' attribute'.",
+                    ),
+                    category=DeprecationWarning,
+                    stacklevel=2,
+                )
+            self.interpolation2d = interpolation
+
+    @property
+    def interpolation2d(self):
+        return str(self._interpolation2d)
+
+    @interpolation2d.setter
+    def interpolation2d(self, value):
+        if value == 'bilinear':
+            raise ValueError(
+                trans._(
+                    "'bilinear' interpolation is not valid for interpolation2d. Did you mean 'linear' instead ?",
+                ),
+            )
+        if value == 'bicubic':
+            value = 'cubic'
+            warnings.warn(
+                trans._("'bicubic' is deprecated. Please use 'cubic' instead"),
+                category=DeprecationWarning,
+                stacklevel=2,
+            )
+        self._interpolation2d = Interpolation(value)
+        self.events.interpolation2d(value=self._interpolation2d)
+        self.events.interpolation(value=self._interpolation2d)
+
+    @property
+    def interpolation3d(self):
+        return str(self._interpolation3d)
+
+    @interpolation3d.setter
+    def interpolation3d(self, value):
+        if value == 'custom':
+            raise NotImplementedError(
+                'custom interpolation is not implemented yet for 3D rendering'
+            )
+        if value == 'bicubic':
+            value = 'cubic'
+            warnings.warn(
+                trans._("'bicubic' is deprecated. Please use 'cubic' instead"),
+                category=DeprecationWarning,
+                stacklevel=2,
+            )
+        self._interpolation3d = Interpolation(value)
+        self.events.interpolation3d(value=self._interpolation3d)
+        self.events.interpolation(value=self._interpolation3d)
+
+    @property
+    def iso_threshold(self) -> float:
+        """float: threshold for isosurface."""
+        return self._iso_threshold
+
+    @iso_threshold.setter
+    def iso_threshold(self, value: float):
+        self._iso_threshold = value
+        self._update_thumbnail()
+        self.events.iso_threshold()
+
+    def _get_level_shapes(self):
+        shapes = super()._get_level_shapes()
+        if self.rgb:
+            shapes = [s[:-1] for s in shapes]
+        return shapes
+
+    def _update_thumbnail(self):
+        """Update thumbnail with current image data and colormap."""
+        image = self._slice.thumbnail.view
+
+        if self._slice_input.ndisplay == 3 and self.ndim > 2:
+            image = np.max(image, axis=0)
+
+        # float16 not supported by ndi.zoom
+        dtype = np.dtype(image.dtype)
+        if dtype in [np.dtype(np.float16)]:
+            image = image.astype(np.float32)
+
+        raw_zoom_factor = np.divide(
+            self._thumbnail_shape[:2], image.shape[:2]
+        ).min()
+        new_shape = np.clip(
+            raw_zoom_factor * np.array(image.shape[:2]),
+            1,  # smallest side should be 1 pixel wide
+            self._thumbnail_shape[:2],
+        )
+        zoom_factor = tuple(new_shape / image.shape[:2])
+        if self.rgb:
+            downsampled = ndi.zoom(
+                image, zoom_factor + (1,), prefilter=False, order=0
+            )
+            if image.shape[2] == 4:  # image is RGBA
+                colormapped = np.copy(downsampled)
+                colormapped[..., 3] = downsampled[..., 3] * self.opacity
+                if downsampled.dtype == np.uint8:
+                    colormapped = colormapped.astype(np.uint8)
+            else:  # image is RGB
+                if downsampled.dtype == np.uint8:
+                    alpha = np.full(
+                        downsampled.shape[:2] + (1,),
+                        int(255 * self.opacity),
+                        dtype=np.uint8,
+                    )
+                else:
+                    alpha = np.full(downsampled.shape[:2] + (1,), self.opacity)
+                colormapped = np.concatenate([downsampled, alpha], axis=2)
+        else:
+            downsampled = ndi.zoom(
+                image, zoom_factor, prefilter=False, order=0
+            )
+            low, high = self.contrast_limits
+            downsampled = np.clip(downsampled, low, high)
+            color_range = high - low
+            if color_range != 0:
+                downsampled = (downsampled - low) / color_range
+            downsampled = downsampled**self.gamma
+            color_array = self.colormap.map(downsampled.ravel())
+            colormapped = color_array.reshape((*downsampled.shape, 4))
+            colormapped[..., 3] *= self.opacity
+        self.thumbnail = colormapped
+
+    def _calc_data_range(self, mode='data') -> Tuple[float, float]:
+        """
+        Calculate the range of the data values in the currently viewed slice
+        or full data array
+        """
+        if mode == 'data':
+            input_data = self.data[-1] if self.multiscale else self.data
+        elif mode == 'slice':
+            data = self._slice.image.view  # ugh
+            input_data = data[-1] if self.multiscale else data
+        else:
+            raise ValueError(
+                trans._(
+                    "mode must be either 'data' or 'slice', got {mode!r}",
+                    deferred=True,
+                    mode=mode,
+                )
+            )
+        return calc_data_range(input_data, rgb=self.rgb)
+
+    def _set_view_slice(self):
+        super()._set_view_slice()
+        if self._should_calc_clims:
+            self.reset_contrast_limits_range()
+            self.reset_contrast_limits()
+            self._should_calc_clims = False
+        elif self._keep_auto_contrast:
+            self.reset_contrast_limits()
+
 
 if config.async_octree:
     from napari.layers.image.experimental.octree_image import _OctreeImageBase
@@ -1153,9 +1396,6 @@ if config.async_octree:
         pass
 
 
-Image.__doc__ = _ImageBase.__doc__
-
-
 class _weakref_hide:
     def __init__(self, obj) -> None:
         import weakref
diff --git a/napari/layers/labels/_labels_key_bindings.py b/napari/layers/labels/_labels_key_bindings.py
index b720ee4e..e244aa14 100644
--- a/napari/layers/labels/_labels_key_bindings.py
+++ b/napari/layers/labels/_labels_key_bindings.py
@@ -6,6 +6,7 @@ from napari.layers.utils.layer_utils import (
     register_layer_action,
     register_layer_attr_action,
 )
+from napari.utils.notifications import show_info
 from napari.utils.translations import trans
 
 MIN_BRUSH_SIZE = 1
@@ -67,7 +68,12 @@ labels_fun_to_mode = [
 )
 def new_label(layer: Labels):
     """Set the currently selected label to the largest used label plus one."""
-    layer.selected_label = np.max(layer.data) + 1
+    if isinstance(layer.data, np.ndarray):
+        layer.selected_label = np.max(layer.data) + 1
+    else:
+        show_info(
+            "Calculating empty label on non-numpy array is not supported"
+        )
 
 
 @register_label_action(
diff --git a/napari/layers/labels/_tests/test_labels_key_bindings.py b/napari/layers/labels/_tests/test_labels_key_bindings.py
index 96db4a6a..f9b8bede 100644
--- a/napari/layers/labels/_tests/test_labels_key_bindings.py
+++ b/napari/layers/labels/_tests/test_labels_key_bindings.py
@@ -1,8 +1,5 @@
-from tempfile import TemporaryDirectory
-
 import numpy as np
 import pytest
-import zarr
 
 from napari.layers import Labels
 from napari.layers.labels._labels_key_bindings import new_label
@@ -21,31 +18,3 @@ def test_max_label(labels_data_4d):
     labels = Labels(labels_data_4d)
     new_label(labels)
     assert labels.selected_label == 4
-
-
-def test_max_label_tensorstore(labels_data_4d):
-    ts = pytest.importorskip('tensorstore')
-
-    with TemporaryDirectory(suffix='.zarr') as fout:
-        labels_temp = zarr.open(
-            fout,
-            mode='w',
-            shape=labels_data_4d.shape,
-            dtype=np.uint32,
-            chunks=(1, 1, 8, 9),
-        )
-        labels_temp[:] = labels_data_4d
-        labels_ts_spec = {
-            'driver': 'zarr',
-            'kvstore': {'driver': 'file', 'path': fout},
-            'path': '',
-            'metadata': {
-                'dtype': labels_temp.dtype.str,
-                'order': labels_temp.order,
-                'shape': labels_data_4d.shape,
-            },
-        }
-        data = ts.open(labels_ts_spec, create=False, open=True).result()
-        layer = Labels(data)
-        new_label(layer)
-        assert layer.selected_label == 4
diff --git a/napari/layers/labels/_tests/test_labels_multiscale.py b/napari/layers/labels/_tests/test_labels_multiscale.py
index 76477be8..dccfe1b6 100644
--- a/napari/layers/labels/_tests/test_labels_multiscale.py
+++ b/napari/layers/labels/_tests/test_labels_multiscale.py
@@ -14,7 +14,6 @@ def test_random_multiscale():
     assert layer.editable is False
     assert layer.ndim == len(shapes[0])
     np.testing.assert_array_equal(layer.extent.data[1], list(shapes[0]))
-    assert layer.rgb is False
     assert layer._data_view.ndim == 2
 
 
@@ -29,7 +28,6 @@ def test_infer_multiscale():
     assert layer.editable is False
     assert layer.ndim == len(shapes[0])
     np.testing.assert_array_equal(layer.extent.data[1], list(shapes[0]))
-    assert layer.rgb is False
     assert layer._data_view.ndim == 2
 
 
@@ -44,7 +42,6 @@ def test_3D_multiscale_labels_in_2D():
     np.testing.assert_array_equal(
         layer.extent.data[1], np.array(data_multiscale[0].shape)
     )
-    assert layer.rgb is False
     assert layer._data_view.ndim == 2
 
     # check corner pixels, should be tuple of highest resolution level
diff --git a/napari/layers/labels/labels.py b/napari/layers/labels/labels.py
index 9de1b59c..2e2f8170 100644
--- a/napari/layers/labels/labels.py
+++ b/napari/layers/labels/labels.py
@@ -74,59 +74,34 @@ class Labels(_ImageBase):
         Labels data as an array or multiscale. Must be integer type or bools.
         Please note multiscale rendering is only supported in 2D. In 3D, only
         the lowest resolution scale is displayed.
-    num_colors : int
-        Number of unique colors to use in colormap.
-    features : dict[str, array-like] or DataFrame
-        Features table where each row corresponds to a label and each column
-        is a feature. The first row corresponds to the background label.
-    properties : dict {str: array (N,)} or DataFrame
-        Properties for each label. Each property should be an array of length
-        N, where N is the number of labels, and the first property corresponds
-        to background.
-    color : dict of int to str or array
-        Custom label to color mapping. Values must be valid color names or RGBA
-        arrays.
-    seed : float
-        Seed for colormap random generator.
-    name : str
-        Name of the layer.
-    metadata : dict
-        Layer metadata.
-    scale : tuple of float
-        Scale factors for the layer.
-    translate : tuple of float
-        Translation values for the layer.
-    rotate : float, 3-tuple of float, or n-D array.
-        If a float convert into a 2D rotation matrix using that value as an
-        angle. If 3-tuple convert into a 3D rotation matrix, using a yaw,
-        pitch, roll convention. Otherwise assume an nD rotation. Angles are
-        assumed to be in degrees. They can be converted from radians with
-        np.degrees if needed.
-    shear : 1-D array or n-D array
-        Either a vector of upper triangular values, or an nD shear matrix with
-        ones along the main diagonal.
     affine : n-D array or napari.utils.transforms.Affine
         (N+1, N+1) affine transformation matrix in homogeneous coordinates.
         The first (N, N) entries correspond to a linear transform and
         the final column is a length N translation vector and a 1 or a napari
         `Affine` transform object. Applied as an extra transform on top of the
         provided scale, rotate, and shear values.
-    opacity : float
-        Opacity of the layer visual, between 0.0 and 1.0.
     blending : str
         One of a list of preset blending modes that determines how RGB and
         alpha values of the layer visual get mixed. Allowed values are
         {'opaque', 'translucent', and 'additive'}.
-    rendering : str
-        3D Rendering mode used by vispy. Must be one {'translucent', 'iso_categorical'}.
-        'translucent' renders without lighting. 'iso_categorical' uses isosurface
-        rendering to calculate lighting effects on labeled surfaces.
-        The default value is 'iso_categorical'.
+    cache : bool
+        Whether slices of out-of-core datasets should be cached upon retrieval.
+        Currently, this only applies to dask arrays.
+    color : dict of int or None to str or array
+        Custom label to color mapping. Values must be valid color names or RGBA
+        arrays. None is used when no color is specified for a label.
     depiction : str
         3D Depiction mode. Must be one of {'volume', 'plane'}.
         The default value is 'volume'.
-    visible : bool
-        Whether the layer visual is currently being displayed.
+    experimental_clipping_planes : list of dicts, list of ClippingPlane, or ClippingPlaneList
+        Each dict defines a clipping plane in 3D in data coordinates.
+        Valid dictionary keys are {'position', 'normal', and 'enabled'}.
+        Values on the negative side of the normal are discarded if the plane is enabled.
+    features : dict[str, array-like] or DataFrame
+        Features table where each row corresponds to a label and each column
+        is a feature. The first row corresponds to the background label.
+    metadata : dict
+        Layer metadata.
     multiscale : bool
         Whether the data is a multiscale image or not. Multiscale data is
         represented by a list of array like image data. If not specified by
@@ -135,17 +110,42 @@ class Labels(_ImageBase):
         should be the largest. Please note multiscale rendering is only
         supported in 2D. In 3D, only the lowest resolution scale is
         displayed.
-    cache : bool
-        Whether slices of out-of-core datasets should be cached upon retrieval.
-        Currently, this only applies to dask arrays.
+    name : str
+        Name of the layer.
+    num_colors : int
+        Number of unique colors to use in colormap.
+    opacity : float
+        Opacity of the layer visual, between 0.0 and 1.0.
     plane : dict or SlicingPlane
         Properties defining plane rendering in 3D. Properties are defined in
         data coordinates. Valid dictionary keys are
         {'position', 'normal', 'thickness', and 'enabled'}.
-    experimental_clipping_planes : list of dicts, list of ClippingPlane, or ClippingPlaneList
-        Each dict defines a clipping plane in 3D in data coordinates.
-        Valid dictionary keys are {'position', 'normal', and 'enabled'}.
-        Values on the negative side of the normal are discarded if the plane is enabled.
+    properties : dict {str: array (N,)} or DataFrame
+        Properties for each label. Each property should be an array of length
+        N, where N is the number of labels, and the first property corresponds
+        to background.
+    rendering : str
+        3D Rendering mode used by vispy. Must be one {'translucent', 'iso_categorical'}.
+        'translucent' renders without lighting. 'iso_categorical' uses isosurface
+        rendering to calculate lighting effects on labeled surfaces.
+        The default value is 'iso_categorical'.
+    rotate : float, 3-tuple of float, or n-D array.
+        If a float convert into a 2D rotation matrix using that value as an
+        angle. If 3-tuple convert into a 3D rotation matrix, using a yaw,
+        pitch, roll convention. Otherwise assume an nD rotation. Angles are
+        assumed to be in degrees. They can be converted from radians with
+        np.degrees if needed.
+    scale : tuple of float
+        Scale factors for the layer.
+    seed_rng : int
+        Seed for colormap shuffle random generator.
+    shear : 1-D array or n-D array
+        Either a vector of upper triangular values, or an nD shear matrix with
+        ones along the main diagonal.
+    translate : tuple of float
+        Translation values for the layer.
+    visible : bool
+        Whether the layer visual is currently being displayed.
 
     Attributes
     ----------
@@ -266,27 +266,27 @@ class Labels(_ImageBase):
         self,
         data,
         *,
-        num_colors=49,
-        features=None,
-        properties=None,
-        color=None,
-        seed_rng=None,
-        name=None,
-        metadata=None,
-        scale=None,
-        translate=None,
-        rotate=None,
-        shear=None,
         affine=None,
-        opacity=0.7,
         blending='translucent',
-        rendering='iso_categorical',
+        cache=True,
+        color=None,
         depiction='volume',
-        visible=True,
+        experimental_clipping_planes=None,
+        features=None,
+        metadata=None,
         multiscale=None,
-        cache=True,
+        name=None,
+        num_colors=49,
+        opacity=0.7,
         plane=None,
-        experimental_clipping_planes=None,
+        properties=None,
+        rendering='iso_categorical',
+        rotate=None,
+        scale=None,
+        seed_rng=None,
+        shear=None,
+        translate=None,
+        visible=True,
     ) -> None:
         if name is None and data is not None:
             name = magic_name(data)
@@ -310,14 +310,8 @@ class Labels(_ImageBase):
 
         super().__init__(
             data,
-            rgb=False,
-            colormap=self._random_colormap,
-            contrast_limits=[0.0, 2**23 - 1.0],
-            interpolation2d='nearest',
-            interpolation3d='nearest',
             rendering=rendering,
             depiction=depiction,
-            iso_threshold=0,
             name=name,
             metadata=metadata,
             scale=scale,
@@ -335,19 +329,20 @@ class Labels(_ImageBase):
         )
 
         self.events.add(
-            preserve_labels=Event,
-            show_selected_label=Event,
-            properties=Event,
-            n_edit_dimensions=Event,
-            contiguous=Event,
+            brush_shape=Event,
             brush_size=Event,
-            selected_label=Event,
             color_mode=Event,
-            brush_shape=Event,
+            colormap=Event,
+            contiguous=Event,
             contour=Event,
             features=Event,
-            paint=Event,
             labels_update=Event,
+            n_edit_dimensions=Event,
+            paint=Event,
+            preserve_labels=Event,
+            properties=Event,
+            selected_label=Event,
+            show_selected_label=Event,
         )
 
         self._feature_table = _FeatureTable.from_layer(
@@ -369,6 +364,7 @@ class Labels(_ImageBase):
         self._status = self.mode
         self._preserve_labels = False
 
+    def _post_init(self):
         self._reset_history()
 
         # Trigger generation of view slice and thumbnail
@@ -563,6 +559,7 @@ class Labels(_ImageBase):
     def data(self, data):
         data = self._ensure_int_labels(data)
         self._data = data
+        self._ndim = len(self._data.shape)
         self._update_dims()
         self.events.data(value=self.data)
         self._reset_editable()
@@ -835,16 +832,6 @@ class Labels(_ImageBase):
         self._preserve_labels = preserve_labels
         self.events.preserve_labels(preserve_labels=preserve_labels)
 
-    @property
-    def contrast_limits(self):
-        return self._contrast_limits
-
-    @contrast_limits.setter
-    def contrast_limits(self, value):
-        # Setting contrast_limits of labels layers leads to wrong visualization
-        # of the layer, so we ignore the value
-        self._contrast_limits = (0, 1)
-
     def _reset_editable(self) -> None:
         self.editable = not self.multiscale
 
diff --git a/napari/utils/events/evented_model.py b/napari/utils/events/evented_model.py
index 03ce70bb..9555e62e 100644
--- a/napari/utils/events/evented_model.py
+++ b/napari/utils/events/evented_model.py
@@ -243,6 +243,7 @@ class EventedModel(BaseModel, metaclass=EventedMetaclass):
         # NOTE: json_encoders are also added EventedMetaclass.__new__ if the
         # field declares a _json_encode method.
         json_encoders = _BASE_JSON_ENCODERS
+        # extra = Extra.forbid
 
     def __init__(self, **kwargs) -> None:
         super().__init__(**kwargs)
-- 
2.34.1

