From 6574c4c9f5353cd61531c2e1acacc4bcabc3df69 Mon Sep 17 00:00:00 2001
From: Grzegorz Bokota <bokota+github@gmail.com>
Date: Wed, 23 Aug 2023 03:53:34 +0200
Subject: [PATCH] Fix oblique button by chekcing if action is generator (#6145)

This Pr fixes a bug that was claimed to be tested in #4265, but it does
not happens (action is dataclass so never will be generator).

As having `orient_plane_normal_along_view_direction` as the generator is
important then I add a separate function
`orient_plane_normal_along_view_direction_no_gen` for this.

- [x] Bug-fix (non-breaking change which fixes an issue)

- [x] Manually

Closes #6040
---
 .../_qt/layer_controls/qt_image_controls.py   |   2 +-
 napari/layers/base/base.py                    | 422 +++++++++++-------
 napari/layers/image/_image_key_bindings.py    |  24 +-
 napari/utils/_tests/test_action_manager.py    |  17 +
 napari/utils/action_manager.py                |   9 +-
 5 files changed, 307 insertions(+), 167 deletions(-)

diff --git a/napari/_qt/layer_controls/qt_image_controls.py b/napari/_qt/layer_controls/qt_image_controls.py
index 3733372c..eb5e8c0b 100644
--- a/napari/_qt/layer_controls/qt_image_controls.py
+++ b/napari/_qt/layer_controls/qt_image_controls.py
@@ -120,7 +120,7 @@ class QtImageControls(QtBaseImageControls):
             self.planeNormalButtons.xButton,
         )
         action_manager.bind_button(
-            'napari:orient_plane_normal_along_view_direction',
+            'napari:orient_plane_normal_along_view_direction_no_gen',
             self.planeNormalButtons.obliqueButton,
         )
 
diff --git a/napari/layers/base/base.py b/napari/layers/base/base.py
index 8231e087..1fbfefb2 100644
--- a/napari/layers/base/base.py
+++ b/napari/layers/base/base.py
@@ -1,13 +1,24 @@
 from __future__ import annotations
 
 import itertools
+import logging
 import os.path
 import warnings
 from abc import ABC, abstractmethod
-from collections import defaultdict, namedtuple
+from collections import defaultdict
 from contextlib import contextmanager
 from functools import cached_property
-from typing import List, Optional, Tuple, Union
+from typing import (
+    TYPE_CHECKING,
+    Callable,
+    ClassVar,
+    Dict,
+    List,
+    Optional,
+    Tuple,
+    Type,
+    Union,
+)
 
 import magicgui as mgui
 import numpy as np
@@ -23,6 +34,7 @@ from napari.layers.utils.interactivity_utils import (
     drag_data_to_projected_distance,
 )
 from napari.layers.utils.layer_utils import (
+    Extent,
     coerce_affine,
     compute_multiscale_level_and_corners,
     convert_to_uint8,
@@ -30,6 +42,7 @@ from napari.layers.utils.layer_utils import (
     get_extent_world,
 )
 from napari.layers.utils.plane import ClippingPlane, ClippingPlaneList
+from napari.settings import get_settings
 from napari.utils._dask_utils import configure_dask
 from napari.utils._magicgui import (
     add_layer_to_viewer,
@@ -43,13 +56,18 @@ from napari.utils.geometry import (
     intersect_line_with_axis_aligned_bounding_box_3d,
 )
 from napari.utils.key_bindings import KeymapProvider
+from napari.utils.misc import StringEnum
 from napari.utils.mouse_bindings import MousemapProvider
 from napari.utils.naming import magic_name
 from napari.utils.status_messages import generate_layer_coords_status
 from napari.utils.transforms import Affine, CompositeAffine, TransformChain
 from napari.utils.translations import trans
 
-Extent = namedtuple('Extent', 'data world step')
+if TYPE_CHECKING:
+    import numpy.typing as npt
+
+
+logger = logging.getLogger("napari.layers.base.base")
 
 
 def no_op(layer: Layer, event: Event) -> None:
@@ -224,18 +242,18 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
     * `_basename()`: base/default name of the layer
     """
 
-    _modeclass = Mode
+    _modeclass: Type[StringEnum] = Mode
 
-    _drag_modes = {
+    _drag_modes: ClassVar[Dict[StringEnum, Callable[[Layer, Event], None]]] = {
         Mode.PAN_ZOOM: no_op,
         Mode.TRANSFORM: transform_with_box,
     }
 
-    _move_modes = {
+    _move_modes: ClassVar[Dict[StringEnum, Callable[[Layer, Event], None]]] = {
         Mode.PAN_ZOOM: no_op,
         Mode.TRANSFORM: highlight_box_handles,
     }
-    _cursor_modes = {
+    _cursor_modes: ClassVar[Dict[StringEnum, str]] = {
         Mode.PAN_ZOOM: 'standard',
         Mode.TRANSFORM: 'standard',
     }
@@ -304,6 +322,8 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
             point=(0,) * ndim,
             order=tuple(range(ndim)),
         )
+        self._loaded: bool = True
+        self._last_slice_id: int = -1
 
         # Create a transform chain consisting of four transforms:
         # 1. `tile2data`: An initial transform only needed to display tiles
@@ -389,22 +409,10 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
             cursor_size=Event,
             editable=Event,
             loaded=Event,
+            reload=Event,
             extent=Event,
+            _extent_augmented=Event,
             _overlays=Event,
-            select=WarningEmitter(
-                trans._(
-                    "'layer.events.select' is deprecated and will be removed in napari v0.4.9, use 'viewer.layers.selection.events.changed' instead, and inspect the 'added' attribute on the event.",
-                    deferred=True,
-                ),
-                type_name='select',
-            ),
-            deselect=WarningEmitter(
-                trans._(
-                    "'layer.events.deselect' is deprecated and will be removed in napari v0.4.9, use 'viewer.layers.selection.events.changed' instead, and inspect the 'removed' attribute on the event.",
-                    deferred=True,
-                ),
-                type_name='deselect',
-            ),
             mode=Event,
         )
         self.name = name
@@ -429,10 +437,16 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
         cls = type(self)
         return f"<{cls.__name__} layer {self.name!r} at {hex(id(self))}>"
 
-    def _mode_setter_helper(self, mode):
+    def _mode_setter_helper(self, mode: Union[Mode, str]) -> Mode:
         """
         Helper to manage callbacks in multiple layers
 
+        This will return a valid mode for the current layer, to for example
+        refuse to set a mode that is not supported by the layer if it is not editable.
+
+        This will as well manage the mouse callbacks.
+
+
         Parameters
         ----------
         mode : type(self._modeclass) | str
@@ -440,7 +454,8 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
 
         Returns
         -------
-        bool : whether mode changed
+        mode : type(self._modeclass)
+            New mode for the current layer.
 
         """
         mode = self._modeclass(mode)
@@ -450,7 +465,7 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
         if mode == self._mode:
             return mode
 
-        if mode.value not in self._modeclass.keys():
+        if mode not in self._modeclass:
             raise ValueError(
                 trans._(
                     "Mode not recognized: {mode}", deferred=True, mode=mode
@@ -540,12 +555,37 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
 
     @property
     def loaded(self) -> bool:
-        """Return True if this layer is fully loaded in memory.
+        """True if this layer is fully loaded in memory, False otherwise.
 
-        This base class says that layers are permanently in the loaded state.
-        Derived classes that do asynchronous loading can override this.
+        Layers that only support sync slicing are always fully loaded.
+        Layers that support async slicing can be temporarily not loaded
+        while slicing is occurring.
         """
-        return True
+        return self._loaded
+
+    def _set_loaded(self, loaded: bool) -> None:
+        """Set the loaded state and notify a change with the loaded event."""
+        if self._loaded != loaded:
+            self._loaded = loaded
+            self.events.loaded()
+
+    def _set_unloaded_slice_id(self, slice_id: int) -> None:
+        """Set this layer to be unloaded and associated with a pending slice ID.
+
+        This is private but accessed externally because it is related to slice
+        state, which is intended to be moved off the layer in the future.
+        """
+        self._last_slice_id = slice_id
+        self._set_loaded(False)
+
+    def _update_loaded_slice_id(self, slice_id: int) -> None:
+        """Potentially update the loaded state based on the given completed slice ID.
+
+        This is private but accessed externally because it is related to slice
+        state, which is intended to be moved off the layer in the future.
+        """
+        if self._last_slice_id == slice_id:
+            self._set_loaded(True)
 
     @property
     def opacity(self):
@@ -644,7 +684,7 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
         if scale is None:
             scale = [1] * self.ndim
         self._transforms['data2physical'].scale = np.array(scale)
-        self._clear_extent()
+        self._clear_extents_and_refresh()
         self.events.scale()
 
     @property
@@ -655,7 +695,7 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
     @translate.setter
     def translate(self, translate):
         self._transforms['data2physical'].translate = np.array(translate)
-        self._clear_extent()
+        self._clear_extents_and_refresh()
         self.events.translate()
 
     @property
@@ -666,7 +706,7 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
     @rotate.setter
     def rotate(self, rotate):
         self._transforms['data2physical'].rotate = rotate
-        self._clear_extent()
+        self._clear_extents_and_refresh()
         self.events.rotate()
 
     @property
@@ -677,7 +717,7 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
     @shear.setter
     def shear(self, shear):
         self._transforms['data2physical'].shear = shear
-        self._clear_extent()
+        self._clear_extents_and_refresh()
         self.events.shear()
 
     @property
@@ -693,31 +733,9 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
         self._transforms[2] = coerce_affine(
             affine, ndim=self.ndim, name='physical2world'
         )
-        self._clear_extent()
+        self._clear_extents_and_refresh()
         self.events.affine()
 
-    @property
-    def translate_grid(self):
-        warnings.warn(
-            trans._(
-                "translate_grid will become private in v0.4.14. See Layer.translate or Layer.data_to_world() instead.",
-            ),
-            DeprecationWarning,
-            stacklevel=2,
-        )
-        return self._translate_grid
-
-    @translate_grid.setter
-    def translate_grid(self, translate_grid):
-        warnings.warn(
-            trans._(
-                "translate_grid will become private in v0.4.14. See Layer.translate or Layer.data_to_world() instead.",
-            ),
-            DeprecationWarning,
-            stacklevel=2,
-        )
-        self._translate_grid = translate_grid
-
     @property
     def _translate_grid(self):
         """list: Factors to shift the layer by."""
@@ -725,7 +743,7 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
 
     @_translate_grid.setter
     def _translate_grid(self, translate_grid):
-        if np.all(self._translate_grid == translate_grid):
+        if np.array_equal(self._translate_grid, translate_grid):
             return
         self._transforms['world2grid'].translate = np.array(translate_grid)
         self.events.translate()
@@ -757,7 +775,7 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
 
         self._ndim = ndim
 
-        self._clear_extent()
+        self._clear_extents_and_refresh()
 
     @property
     @abstractmethod
@@ -781,43 +799,109 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
         """
         raise NotImplementedError
 
+    @property
+    def _extent_data_augmented(self) -> np.ndarray:
+        """Extent of layer in data coordinates.
+
+        Differently from Layer._extent_data, this also includes the "size" of
+        data points; for example, Point sizes and Image pixel width are included.
+
+        Returns
+        -------
+        extent_data : array, shape (2, D)
+        """
+        return self._extent_data
+
     @property
     def _extent_world(self) -> np.ndarray:
         """Range of layer in world coordinates.
 
+        Returns
+        -------
+        extent_world : array, shape (2, D)
+        """
+        # Get full nD bounding box
+        return get_extent_world(self._extent_data, self._data_to_world)
+
+    @property
+    def _extent_world_augmented(self) -> np.ndarray:
+        """Range of layer in world coordinates.
+
+        Differently from Layer._extent_world, this also includes the "size" of
+        data points; for example, Point sizes and Image pixel width are included.
+
         Returns
         -------
         extent_world : array, shape (2, D)
         """
         # Get full nD bounding box
         return get_extent_world(
-            self._extent_data, self._data_to_world, self._array_like
+            self._extent_data_augmented, self._data_to_world
         )
 
     @cached_property
     def extent(self) -> Extent:
-        """Extent of layer in data and world coordinates."""
+        """Extent of layer in data and world coordinates.
+
+        For image-like layers, these coordinates are the locations of the
+        pixels in `Layer.data` which are treated like sample points that are
+        centered in the rendered version of those pixels.
+        For other layers, these coordinates are the points or vertices stored
+        in `Layer.data`.
+        Lower and upper bounds are inclusive.
+        """
         extent_data = self._extent_data
         data_to_world = self._data_to_world
-        extent_world = get_extent_world(
-            extent_data, data_to_world, self._array_like
-        )
+        extent_world = get_extent_world(extent_data, data_to_world)
         return Extent(
             data=extent_data,
             world=extent_world,
             step=abs(data_to_world.scale),
         )
 
-    def _clear_extent(self):
-        """Clears the cached extent.
+    @cached_property
+    def _extent_augmented(self) -> Extent:
+        """Augmented extent of layer in data and world coordinates.
 
-        This should be called whenever this data or transform information
-        changes, and should be called before any related events get emitted
-        so that they use the updated extent values.
+        Differently from Layer.extent, this also includes the "size" of data
+        points; for example, Point sizes and Image pixel width are included.
+
+        For image-like layers, these coordinates are the locations of the
+        pixels in `Layer.data` which are treated like sample points that are
+        centered in the rendered version of those pixels.
+        For other layers, these coordinates are the points or vertices stored
+        in `Layer.data`.
         """
+        extent_data = self._extent_data_augmented
+        data_to_world = self._data_to_world
+        extent_world = get_extent_world(extent_data, data_to_world)
+        return Extent(
+            data=extent_data,
+            world=extent_world,
+            step=abs(data_to_world.scale),
+        )
+
+    def _clear_extent(self):
+        """Clear extent cache and emit extent event."""
         if 'extent' in self.__dict__:
             del self.extent
         self.events.extent()
+
+    def _clear_extent_augmented(self):
+        """Clear extent_augmented cache and emit extent_augmented event."""
+        if '_extent_augmented' in self.__dict__:
+            del self._extent_augmented
+        self.events._extent_augmented()
+
+    def _clear_extents_and_refresh(self):
+        """Clears the cached extents, emits events and refreshes the layer.
+
+        This should be called whenever this data or transform information
+        changes, and should be called before any other related events
+        are emitted so that they use the updated extent values.
+        """
+        self._clear_extent()
+        self._clear_extent_augmented()
         self.refresh()
 
     @property
@@ -1032,7 +1116,9 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
     def _set_view_slice(self):
         raise NotImplementedError
 
-    def _slice_dims(self, point=None, ndisplay=2, order=None):
+    def _slice_dims(
+        self, point=None, ndisplay=2, order=None, force: bool = False
+    ):
         """Slice data with values from a global dims model.
 
         Note this will likely be moved off the base layer soon.
@@ -1046,7 +1132,26 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
         order : list of int
             Order of dimensions, where last `ndisplay` will be
             rendered in canvas.
+        force: bool
+            True if slicing should be forced to occur, even when some cache thinks
+            it already has a valid slice ready. False otherwise.
         """
+        logger.debug(
+            'Layer._slice_dims: %s, point=%s, ndisplay=%s, order=%s, force=%s',
+            self,
+            point,
+            ndisplay,
+            order,
+            force,
+        )
+        slice_input = self._make_slice_input(point, ndisplay, order)
+        if force or (self._slice_input != slice_input):
+            self._slice_input = slice_input
+            self._refresh_sync()
+
+    def _make_slice_input(
+        self, point=None, ndisplay=2, order=None
+    ) -> _SliceInput:
         point = (0,) * self.ndim if point is None else tuple(point)
 
         ndim = len(point)
@@ -1061,21 +1166,12 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
             self._world_to_layer_dims(world_dims=order, ndim_world=ndim)
         )
 
-        slice_input = _SliceInput(
+        return _SliceInput(
             ndisplay=ndisplay,
             point=point,
             order=order,
         )
 
-        if self._slice_input == slice_input:
-            return
-
-        self._slice_input = slice_input
-
-        # Update the point values
-        self.refresh()
-        self._reset_editable()
-
     @abstractmethod
     def _update_thumbnail(self):
         raise NotImplementedError
@@ -1098,11 +1194,11 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
 
     def get_value(
         self,
-        position: Tuple[float],
+        position: npt.ArrayLike,
         *,
-        view_direction: Optional[np.ndarray] = None,
+        view_direction: Optional[npt.ArrayLike] = None,
         dims_displayed: Optional[List[int]] = None,
-        world=False,
+        world: bool = False,
     ):
         """Value of the data at a position.
 
@@ -1127,6 +1223,7 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
         value : tuple, None
             Value of the data. If the layer is not visible return None.
         """
+        position = np.asarray(position)
         if self.visible:
             if world:
                 ndim_world = len(position)
@@ -1147,9 +1244,7 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
                     value = self._get_value(position=tuple(position))
 
                 elif len(dims_displayed) == 3:
-                    view_direction = self._world_to_data_ray(
-                        list(view_direction)
-                    )
+                    view_direction = self._world_to_data_ray(view_direction)
                     start_point, end_point = self.get_ray_intersections(
                         position=position,
                         view_direction=view_direction,
@@ -1198,11 +1293,11 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
 
     def projected_distance_from_mouse_drag(
         self,
-        start_position: np.ndarray,
-        end_position: np.ndarray,
-        view_direction: np.ndarray,
+        start_position: npt.ArrayLike,
+        end_position: npt.ArrayLike,
+        view_direction: npt.ArrayLike,
         vector: np.ndarray,
-        dims_displayed: Union[List, np.ndarray],
+        dims_displayed: List[int],
     ):
         """Calculate the length of the projection of a line between two mouse
         clicks onto a vector (or array of vectors) in data coordinates.
@@ -1220,13 +1315,17 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
             (3,) unit vector or (n, 3) array thereof on which to project the drag
             vector from start_event to end_event. This argument is defined in data
             coordinates.
-        dims_displayed : Union[List, np.ndarray]
+        dims_displayed : List[int]
             (3,) list of currently displayed dimensions
 
         Returns
         -------
         projected_distance : (1, ) or (n, ) np.ndarray of float
         """
+        start_position = np.asarray(start_position)
+        end_position = np.asarray(end_position)
+        view_direction = np.asarray(view_direction)
+
         start_position = self._world_to_displayed_data(
             start_position, dims_displayed
         )
@@ -1260,13 +1359,23 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
 
     def refresh(self, event=None):
         """Refresh all layer data based on current view slice."""
+        logger.debug('Layer.refresh: %s', self)
+        # If async is enabled then emit an event that the viewer should handle.
+        if get_settings().experimental.async_:
+            self.events.reload(layer=self)
+        # Otherwise, slice immediately on the calling thread.
+        else:
+            self._refresh_sync()
+
+    def _refresh_sync(self, event=None):
+        logger.debug('Layer._refresh_sync: %s', self)
         if self.visible:
             self.set_view_slice()
             self.events.set_data()
             self._update_thumbnail()
             self._set_highlight(force=True)
 
-    def world_to_data(self, position):
+    def world_to_data(self, position: npt.ArrayLike) -> npt.NDArray:
         """Convert from world coordinates to data coordinates.
 
         Parameters
@@ -1281,12 +1390,13 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
         tuple
             Position in data coordinates.
         """
+        position = np.asarray(position)
         if len(position) >= self.ndim:
             coords = list(position[-self.ndim :])
         else:
             coords = [0] * (self.ndim - len(position)) + list(position)
 
-        return tuple(self._transforms[1:].simplified.inverse(coords))
+        return self._transforms[1:].simplified.inverse(coords)
 
     def data_to_world(self, position):
         """Convert from data coordinates to world coordinates.
@@ -1311,8 +1421,8 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
         return tuple(self._transforms[1:].simplified(coords))
 
     def _world_to_displayed_data(
-        self, position: np.ndarray, dims_displayed: np.ndarray
-    ) -> tuple:
+        self, position: np.ndarray, dims_displayed: List[int]
+    ) -> npt.NDArray:
         """Convert world to data coordinates for displayed dimensions only.
 
         Parameters
@@ -1321,7 +1431,7 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
             Position in world coordinates. If longer then the
             number of dimensions of the layer, the later
             dimensions will be used.
-        dims_displayed : list, 1D array
+        dims_displayed : list[int]
             Indices of displayed dimensions of the data.
 
         Returns
@@ -1330,8 +1440,8 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
             Position in data coordinates for the displayed dimensions only
         """
         position_nd = self.world_to_data(position)
-        position_ndisplay = np.asarray(position_nd)[dims_displayed]
-        return tuple(position_ndisplay)
+        position_ndisplay = position_nd[dims_displayed]
+        return position_ndisplay
 
     @property
     def _data_to_world(self) -> Affine:
@@ -1344,7 +1454,7 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
         """
         return self._transforms[1:3].simplified
 
-    def _world_to_data_ray(self, vector) -> tuple:
+    def _world_to_data_ray(self, vector: npt.ArrayLike) -> npt.NDArray:
         """Convert a vector defining an orientation from world coordinates to data coordinates.
         For example, this would be used to convert the view ray.
 
@@ -1362,10 +1472,10 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
         p0 = np.asarray(self.world_to_data(np.zeros_like(vector)))
         normalized_vector = (p1 - p0) / np.linalg.norm(p1 - p0)
 
-        return tuple(normalized_vector)
+        return normalized_vector
 
     def _world_to_displayed_data_ray(
-        self, vector_world, dims_displayed
+        self, vector_world: npt.ArrayLike, dims_displayed: List[int]
     ) -> np.ndarray:
         """Convert an orientation from world to displayed data coordinates.
 
@@ -1373,7 +1483,7 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
 
         Parameters
         ----------
-        vector_world : tuple, list, 1D array
+        vector_world : 1D array
             A vector in world coordinates.
 
         Returns
@@ -1381,14 +1491,14 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
         tuple
             Vector in data coordinates.
         """
-        vector_data_nd = np.asarray(self._world_to_data_ray(vector_world))
+        vector_data_nd = self._world_to_data_ray(vector_world)
         vector_data_ndisplay = vector_data_nd[dims_displayed]
         vector_data_ndisplay /= np.linalg.norm(vector_data_ndisplay)
         return vector_data_ndisplay
 
     def _world_to_layer_dims(
-        self, *, world_dims: List[int], ndim_world: int
-    ) -> List[int]:
+        self, *, world_dims: npt.NDArray, ndim_world: int
+    ) -> np.ndarray:
         """Map world dimensions to layer dimensions while maintaining order.
 
         This is used to map dimensions from the full world space defined by ``Dims``
@@ -1402,32 +1512,44 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
 
         Parameters
         ----------
-        world_dims : List[int]
+        world_dims : ndarray
             The world dimensions.
         ndim_world : int
             The number of dimensions in the world coordinate system.
 
         Returns
         -------
-        List[int]
+        ndarray
             The corresponding layer dimensions with the same ordering as the given world dimensions.
         """
         offset = ndim_world - self.ndim
         order = np.array(world_dims)
-        if offset <= 0:
-            return list(range(-offset)) + list(order - offset)
+        if offset == 0:
+            return order
+        if offset < 0:
+            return np.concatenate(np.arange(-offset), order - offset)
 
-        return list(order[order >= offset] - offset)
+        return order[order >= offset] - offset
 
-    def _display_bounding_box(self, dims_displayed: np.ndarray):
+    def _display_bounding_box(self, dims_displayed: List[int]) -> npt.NDArray:
         """An axis aligned (ndisplay, 2) bounding box around the data"""
         return self._extent_data[:, dims_displayed].T
 
+    def _display_bounding_box_augmented(
+        self, dims_displayed: List[int]
+    ) -> npt.NDArray:
+        """An augmented, axis-aligned (ndisplay, 2) bounding box.
+
+        This bounding box for includes the "full" size of the layer, including
+        for example the size of points or pixels.
+        """
+        return self._extent_data_augmented[:, dims_displayed].T
+
     def click_plane_from_click_data(
         self,
-        click_position: np.ndarray,
-        view_direction: np.ndarray,
-        dims_displayed: List,
+        click_position: npt.ArrayLike,
+        view_direction: npt.ArrayLike,
+        dims_displayed: List[int],
     ) -> Tuple[np.ndarray, np.ndarray]:
         """Calculate a (point, normal) plane parallel to the canvas in data
         coordinates, centered on the centre of rotation of the camera.
@@ -1438,7 +1560,7 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
             click position in world coordinates from mouse event.
         view_direction : np.ndarray
             view direction in world coordinates from mouse event.
-        dims_displayed : List
+        dims_displayed : List[int]
             dimensions of the data array currently in view.
 
         Returns
@@ -1454,8 +1576,8 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
 
     def get_ray_intersections(
         self,
-        position: List[float],
-        view_direction: np.ndarray,
+        position: npt.ArrayLike,
+        view_direction: npt.ArrayLike,
         dims_displayed: List[int],
         world: bool = True,
     ) -> Union[Tuple[np.ndarray, np.ndarray], Tuple[None, None]]:
@@ -1470,7 +1592,7 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
         view_direction : np.ndarray
             a unit vector giving the direction of the ray in nD coordinates.
             World vs. data is set by the world keyword argument.
-        dims_displayed
+        dims_displayed : List[int]
             a list of the dimensions currently being displayed in the viewer.
         world : bool
             True if the provided coordinates are in world coordinates.
@@ -1491,11 +1613,15 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
             If the click does not intersect the axis-aligned data bounding box,
             None is returned.
         """
+        position = np.asarray(position)
+        view_direction = np.asarray(view_direction)
         if len(dims_displayed) != 3:
             return None, None
 
         # create the bounding box in data coordinates
         bounding_box = self._display_bounding_box(dims_displayed)
+        # bounding box is with upper limit excluded in the uses below
+        bounding_box[:, 1] += 1
 
         start_point, end_point = self._get_ray_intersections(
             position=position,
@@ -1506,17 +1632,17 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
         )
         return start_point, end_point
 
-    def _get_offset_data_position(self, position: List[float]) -> List[float]:
+    def _get_offset_data_position(self, position: npt.NDArray) -> npt.NDArray:
         """Adjust position for offset between viewer and data coordinates."""
-        return position
+        return np.asarray(position)
 
     def _get_ray_intersections(
         self,
-        position: List[float],
+        position: npt.NDArray,
         view_direction: np.ndarray,
         dims_displayed: List[int],
+        bounding_box: npt.NDArray,
         world: bool = True,
-        bounding_box: Optional[np.ndarray] = None,
     ) -> Union[Tuple[np.ndarray, np.ndarray], Tuple[None, None]]:
         """Get the start and end point for the ray extending
         from a point through the data bounding box.
@@ -1529,7 +1655,7 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
         view_direction : np.ndarray
             a unit vector giving the direction of the ray in nD coordinates.
             World vs. data is set by the world keyword argument.
-        dims_displayed
+        dims_displayed : List[int]
             a list of the dimensions currently being displayed in the viewer.
         world : bool
             True if the provided coordinates are in world coordinates.
@@ -1564,8 +1690,8 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
             # adjust for any offset between viewer and data coordinates
             position = self._get_offset_data_position(position)
 
-            view_dir = np.asarray(view_direction)[dims_displayed]
-            click_pos_data = np.asarray(position)[dims_displayed]
+            view_dir = view_direction[dims_displayed]
+            click_pos_data = position[dims_displayed]
 
         # Determine the front and back faces
         front_face_normal, back_face_normal = find_front_back_face(
@@ -1588,9 +1714,9 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
         )
 
         # add the coordinates for the axes not displayed
-        start_point = np.asarray(position)
+        start_point = position.copy()
         start_point[dims_displayed] = start_point_displayed_dimensions
-        end_point = np.asarray(position)
+        end_point = position.copy()
         end_point[dims_displayed] = end_point_displayed_dimensions
 
         return start_point, end_point
@@ -1648,7 +1774,7 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
             # space of the selected level. Using the level's data
             # shape only works for images, but that's the only case we
             # handle now and downsample_factors is also only on image layers.
-            max_coords = np.take(self.data[level].shape, displayed_axes)
+            max_coords = np.take(self.data[level].shape, displayed_axes) - 1
             corners[:, displayed_axes] = np.clip(scaled_corners, 0, max_coords)
             display_shape = tuple(
                 corners[1, displayed_axes] - corners[0, displayed_axes]
@@ -1661,7 +1787,6 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
                 self._data_level = level
                 self.corner_pixels = corners
                 self.refresh()
-
         else:
             # The stored corner_pixels attribute must contain valid indices.
             corners = np.zeros((2, self.ndim), dtype=int)
@@ -1724,9 +1849,9 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
 
     def get_status(
         self,
-        position: Optional[Tuple[float, ...]] = None,
+        position: Optional[npt.ArrayLike] = None,
         *,
-        view_direction: Optional[np.ndarray] = None,
+        view_direction: Optional[npt.ArrayLike] = None,
         dims_displayed: Optional[List[int]] = None,
         world=False,
     ):
@@ -1753,6 +1878,7 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
             Dictionary containing a information that can be used as a status update.
         """
         if position is not None:
+            position = np.asarray(position)
             value = self.get_value(
                 position,
                 view_direction=view_direction,
@@ -1763,27 +1889,32 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
             value = None
 
         source_info = self._get_source_info()
-        source_info['coordinates'] = generate_layer_coords_status(
-            position[-self.ndim :], value
-        )
+        if position is not None:
+            source_info['coordinates'] = generate_layer_coords_status(
+                position[-self.ndim :], value
+            )
+        else:
+            source_info['coordinates'] = generate_layer_coords_status(
+                position, value
+            )
         return source_info
 
     def _get_tooltip_text(
         self,
-        position,
+        position: npt.NDArray,
         *,
         view_direction: Optional[np.ndarray] = None,
         dims_displayed: Optional[List[int]] = None,
         world: bool = False,
-    ):
+    ) -> str:
         """
         tooltip message of the data at a coordinate position.
 
         Parameters
         ----------
-        position : tuple
+        position : ndarray
             Position in either data or world coordinates.
-        view_direction : Optional[np.ndarray]
+        view_direction : Optional[ndarray]
             A unit vector giving the direction of the ray in nD world coordinates.
             The default value is None.
         dims_displayed : Optional[List[int]]
@@ -1823,21 +1954,12 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
 
         return save_layers(path, [self], plugin=plugin)
 
-    def _on_selection(self, selected: bool):
-        # This method is a temporary workaround to the fact that the Points
-        # layer needs to know when its selection state changes so that it can
-        # update the highlight state.  This, along with the events.select and
-        # events.deselect emitters, (and the LayerList._on_selection_event
-        # method) can be removed once highlighting logic has been removed from
-        # the layer model.
-        if selected:
-            self.events.select()
-        else:
-            self.events.deselect()
-
     @classmethod
     def create(
-        cls, data, meta: dict = None, layer_type: Optional[str] = None
+        cls,
+        data,
+        meta: Optional[dict] = None,
+        layer_type: Optional[str] = None,
     ) -> Layer:
         """Create layer from `data` of type `layer_type`.
 
@@ -1888,7 +2010,7 @@ class Layer(KeymapProvider, MousemapProvider, ABC):
         if not layer_type:
             layer_type = guess_labels(data)
 
-        if layer_type not in layers.NAMES:
+        if layer_type is None or layer_type not in layers.NAMES:
             raise ValueError(
                 trans._(
                     "Unrecognized layer_type: '{layer_type}'. Must be one of: {layer_names}.",
diff --git a/napari/layers/image/_image_key_bindings.py b/napari/layers/image/_image_key_bindings.py
index 763f7f4e..fae417f6 100644
--- a/napari/layers/image/_image_key_bindings.py
+++ b/napari/layers/image/_image_key_bindings.py
@@ -36,7 +36,7 @@ def orient_plane_normal_along_x(layer: Image):
 @register_image_action(trans._('orient plane normal along view direction'))
 def orient_plane_normal_along_view_direction(layer: Image):
     viewer = napari.viewer.current_viewer()
-    if viewer.dims.ndisplay != 3:
+    if viewer is None or viewer.dims.ndisplay != 3:
         return
 
     def sync_plane_normal_with_view_direction(event=None):
@@ -55,18 +55,14 @@ def orient_plane_normal_along_view_direction(layer: Image):
     )
 
 
-@Image.bind_key('Space', overwrite=True)
-def hold_to_pan_zoom(layer):
-    """Hold to pan and zoom in the viewer."""
-    if layer._mode != Mode.PAN_ZOOM:
-        # on key press
-        prev_mode = layer.mode
-        layer.mode = Mode.PAN_ZOOM
-
-        yield
-
-        # on key release
-        layer.mode = prev_mode
+@register_image_action(trans._('orient plane normal along view direction'))
+def orient_plane_normal_along_view_direction_no_gen(layer: Image):
+    viewer = napari.viewer.current_viewer()
+    if viewer is None or viewer.dims.ndisplay != 3:
+        return
+    layer.plane.normal = layer._world_to_displayed_data_ray(
+        viewer.camera.view_direction, [-3, -2, -1]
+    )
 
 
 @register_image_action(trans._('Transform'))
@@ -76,7 +72,7 @@ def activate_image_transform_mode(layer):
 
 @register_image_action(trans._('Pan/zoom'))
 def activate_image_pan_zoom_mode(layer: Image):
-    layer.mode = Mode.PAN_ZOOM
+    layer.mode = str(Mode.PAN_ZOOM)
 
 
 image_fun_to_mode = [
diff --git a/napari/utils/_tests/test_action_manager.py b/napari/utils/_tests/test_action_manager.py
index 877ed255..b3562cd1 100644
--- a/napari/utils/_tests/test_action_manager.py
+++ b/napari/utils/_tests/test_action_manager.py
@@ -1,6 +1,8 @@
 """
 This module test some of the behavior of action manager.
 """
+from unittest.mock import Mock
+
 import pytest
 
 from napari.utils.action_manager import ActionManager
@@ -48,3 +50,18 @@ def test_bind_unbind_existing_action(action_manager):
     assert action_manager.bind_shortcut('napari:test_action_1', 'X') is None
     assert action_manager.unbind_shortcut('napari:test_action_1') == ['X']
     assert action_manager._shortcuts['napari:test_action_1'] == []
+
+
+def test_bind_key_generator(action_manager):
+    def _sample_generator():
+        yield 'X'
+
+    action_manager.register_action(
+        "napari:test_action_1",
+        _sample_generator,
+        "this is a test action",
+        None,
+    )
+
+    with pytest.raises(ValueError, match="generator functions"):
+        action_manager.bind_button('napari:test_action_1', Mock())
diff --git a/napari/utils/action_manager.py b/napari/utils/action_manager.py
index 0dcc0684..e60d7739 100644
--- a/napari/utils/action_manager.py
+++ b/napari/utils/action_manager.py
@@ -216,7 +216,9 @@ class ActionManager:
         """
         self._validate_action_name(name)
 
-        if (action := self._actions.get(name)) and isgeneratorfunction(action):
+        if (action := self._actions.get(name)) and isgeneratorfunction(
+            getattr(action, "command", None)
+        ):
             raise ValueError(
                 trans._(
                     '`bind_button` cannot be used with generator functions',
@@ -224,7 +226,10 @@ class ActionManager:
                 )
             )
 
-        button.clicked.connect(lambda: self.trigger(name))
+        def _trigger():
+            self.trigger(name)
+
+        button.clicked.connect(_trigger)
         if name in self._actions:
             button.setToolTip(
                 f'{self._build_tooltip(name)} {extra_tooltip_text}'
-- 
2.34.1
